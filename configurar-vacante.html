<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UBITS - Configurar vacante</title>
    
    <!-- Estilos UBITS oficiales -->
    <link rel="stylesheet" href="ubits-colors.css">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="fontawesome-icons.css">
    <link rel="stylesheet" href="ubits-typography.css">
    <link rel="stylesheet" href="components/sub-nav.css">
    <link rel="stylesheet" href="components-sidebar.css">
    <link rel="stylesheet" href="components/tab-bar-reclutamiento.css">
    <link rel="stylesheet" href="components/floating-menu.css">
    <link rel="stylesheet" href="components/profile-menu.css">
    <link rel="stylesheet" href="components/input.css">
    <link rel="stylesheet" href="components/button.css">
    <link rel="stylesheet" href="components/modal.css">
    <link rel="stylesheet" href="components/toast.css">
    <link rel="stylesheet" href="profile.css">
    <style>
        /* Estilos específicos para content-sections */
        .content-sections {
            display: flex;
            flex-direction: column;
            gap: 16px !important; /* Forzar gap consistente */
            flex: 1;
            min-width: 0;
            width: 100%;
            overflow: visible;
            max-height: none;
        }

        /* Asegurar que todas las secciones tengan el mismo gap */
        .content-sections > .section-single,
        .content-sections > .section-dual,
        .content-sections > .section-triple,
        .content-sections > .section-quad {
            margin-bottom: 0; /* El gap se maneja con gap del flexbox */
        }

        /* Espaciador final */
        .content-sections::after {
            content: '';
            height: 0px;
            flex-shrink: 0;
        }

        /* Secciones de widgets */
        .section-single {
            display: flex;
            width: 100%;
            max-width: 100%;
            min-width: 0;
        }

        .section-dual {
            display: flex;
            gap: 20px;
        }

        .section-triple {
            display: flex;
            gap: 20px;
        }

        .section-quad {
            display: flex;
            gap: 20px;
        }

        /* Widgets en secciones - sin altura mínima forzada */
        .section-single > div,
        .section-dual > div,
        .section-triple > div,
        .section-quad > div {
            background-color: var(--ubits-bg-1);
            border: none;
            border-radius: 8px;
            padding: 16px !important;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        

        /* Distribución de anchos */
        .section-single > div {
            flex: 1;
        }
        
        .section-single > .widget-template-flow {
            flex: 1;
            width: 100%;
            max-width: 100%;
            min-width: 0;
        }

        .section-dual > div {
            flex: 1;
        }

        /* Widget de biblioteca en section-dual */
        .section-dual > .widget-library {
            flex: 0 0 40%;
            max-width: 40%;
            min-width: 0;
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 600px;
        }

        /* Widget de flujo en section-dual */
        .section-dual > .widget-template-flow {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: none;
        }

        .section-triple > div {
            flex: 1;
        }

        .section-quad > div {
            flex: 1;
        }

        /* Responsive para secciones */
        @media (max-width: 1023px) {
            .content-sections {
                padding-bottom: 0;
            }
            
            .section-dual,
            .section-triple,
            .section-quad {
                flex-direction: column;
                gap: 16px;
            }
        }

        @media (max-width: 480px) {
            /* Padding reducido en móviles pequeños */
            .section-single > div,
            .section-dual > div,
            .section-triple > div,
            .section-quad > div {
                padding: 12px !important;
            }
        }

        /* Widget Stepper */
        .widget-stepper {
            background-color: var(--ubits-bg-1);
            border-radius: 8px;
            padding: 24px;
            border: none;
        }

        @media (max-width: 768px) {
            .widget-stepper {
                padding: 16px;
                margin-top: 16px;
            }
            
            /* Mobile stepper simplificado */
            .stepper {
                display: none;
            }
            
            .mobile-stepper {
                display: flex;
                align-items: center;
                gap: 16px;
            }
            
            .mobile-progress-circle {
                width: 48px;
                height: 48px;
                border-radius: 50%;
                background: var(--ubits-bg-1);
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: 600;
                font-size: 14px;
                color: var(--ubits-button-primary-bg-default);
                position: relative;
                flex-shrink: 0;
            }
            
            /* Progress circle con SVG */
            .mobile-progress-circle svg {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                transform: rotate(-90deg);
            }
            
            .mobile-progress-circle svg circle {
                fill: none;
                stroke-width: 2;
            }
            
            .mobile-progress-bg {
                stroke: var(--ubits-border-1);
            }
            
            .mobile-progress-fill {
                stroke: var(--ubits-button-primary-bg-default);
                stroke-dasharray: 138; /* 2π * 22 (radio) */
                stroke-dashoffset: 138; /* Comienza vacío */
                transition: stroke-dashoffset 0.3s ease;
            }
            
            /* 2 de 5 pasos = 40% */
            .mobile-progress-circle[data-progress="40"] .mobile-progress-fill {
                stroke-dashoffset: 82.8; /* 138 * (1 - 0.4) */
            }
            
            .mobile-stepper-text {
                flex: 1;
                min-width: 0;
                display: flex;
                flex-direction: column;
                gap: 8px;
            }
            
            .mobile-current-step {
                font-size: 16px;
                font-weight: 600;
                color: var(--ubits-fg-1-high);
            }
            
            .mobile-next-button {
                align-self: flex-start;
            }
        }

        /* Desktop - ocultar mobile stepper */
        @media (min-width: 769px) {
            .mobile-stepper {
                display: none;
            }
        }

        /* Mobile - ocultar desktop stepper */
        @media (max-width: 768px) {
            .stepper {
                display: none !important;
            }
        }

        .stepper {
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .stepper-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            position: relative;
        }

        .stepper-item:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 16px;
            left: calc(50% + 16px);
            width: calc(100% - 32px);
            height: 2px;
            background-color: var(--ubits-border-1);
            z-index: 1;
        }


        .stepper-item.completed:not(:last-child)::after {
            background-color: var(--ubits-feedback-accent-success);
        }

        .stepper-item.active:not(:last-child)::after {
            background-color: var(--ubits-feedback-accent-success);
        }

        .stepper-circle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            position: relative;
            z-index: 2;
            background-color: var(--ubits-bg-1);
            border: 2px solid var(--ubits-border-1);
            color: var(--ubits-fg-1-medium);
        }


        .stepper-item.completed .stepper-circle {
            background-color: var(--ubits-feedback-accent-success);
            border-color: var(--ubits-feedback-accent-success);
            color: var(--ubits-fg-1-low);
        }

        .stepper-item.active .stepper-circle {
            background-color: var(--ubits-button-primary-bg-default);
            border-color: var(--ubits-button-primary-bg-default);
            color: var(--ubits-btn-primary-fg);
        }

        .stepper-label {
            margin-top: 8px;
            font-size: 12px;
            font-weight: 500;
            text-align: center;
            color: var(--ubits-fg-1-medium);
            max-width: 120px;
            line-height: 1.3;
        }


        .stepper-item.completed .stepper-label {
            color: var(--ubits-fg-1-high);
            font-weight: 600;
        }

        .stepper-item.active .stepper-label {
            color: var(--ubits-button-primary-bg-default);
            font-weight: 600;
        }

        .stepper-icon {
            font-size: 14px;
        }


        .config-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            gap: 16px; /* Espacio entre título y switch */
        }

        .config-card-title {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1; /* Permite que el título tome el espacio disponible */
            min-width: 0; /* Permite que el texto se trunce si es necesario */
        }

        .config-card-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--ubits-fg-1-medium);
        }

        .config-card-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--ubits-fg-1-high);
        }

        /* Switch styles - Copiados de button.html */
        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
            flex-shrink: 0; /* Evita que el switch se comprima */
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--ubits-border-1);
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: var(--ubits-accent-brand);
        }
        
        input:checked + .slider:before {
            transform: translateX(20px);
        }

        .config-fields {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .field-group {
            flex: 1;
        }

        .field-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--ubits-fg-1-medium);
            margin-bottom: 8px;
            display: block;
        }

        .field-input {
            width: 100%;
            height: 40px;
            padding: 0 12px;
            border: 1px solid var(--ubits-border-1);
            border-radius: 6px;
            background-color: var(--ubits-bg-1);
            color: var(--ubits-fg-1-high);
            font-size: 14px;
            transition: border-color 0.2s ease;
        }

        .field-input:focus {
            outline: none;
            border-color: var(--ubits-feedback-accent-info);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        /* Widget Template Selector */
        .widget-template-selector {
            background-color: var(--ubits-bg-1);
            border-radius: 8px;
            padding: 20px;
            border: none;
        }

        /* Widget Notifications */
        .widget-notifications {
            background-color: var(--ubits-bg-1);
            border-radius: 8px;
            padding: 20px;
            border: none;
        }

        .selector-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .selector-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--ubits-fg-1-medium);
        }

        .selector-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--ubits-fg-1-high);
        }

        /* Widget Template Flow - Estilos del editor */
        .widget-template-flow {
            background-color: var(--ubits-bg-1);
            border-radius: 8px;
            padding: 20px;
            border: none;
            width: 100%;
            max-width: 100%;
            min-width: 0;
            box-sizing: border-box;
        }

        .flow-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
            gap: 16px;
        }

        .flow-header-title {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .flow-header-title i {
            font-size: 20px;
            color: var(--ubits-fg-1-medium);
        }

        .flow-header-title h3 {
            margin: 0;
            color: var(--ubits-fg-1-high);
        }

        .flow-header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .agent-stage-config {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 0;
        }

        .agent-stage-config.expanded {
            max-height: 1000px;
            opacity: 1;
        }

        /* Editor Layout - Igual que en el editor */
        .editor-layout {
            display: flex;
            gap: 16px;
            flex: 1;
            min-height: 0;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow-x: hidden;
            overflow-y: visible;
        }

        /* Sidebar de agentes */
        .agents-sidebar {
            width: 100%;
            height: 100%;
            background: var(--ubits-bg-1);
            border: none;
            border-width: 0;
            border-color: transparent;
            border-style: none;
            border-image: none;
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            box-sizing: border-box;
            overflow-x: visible;
            overflow-y: hidden; /* Sin scroll en el sidebar completo */
            min-height: 0;
            flex: 1;
            position: relative;
        }

        /* Asegurar que los tabs no corten el badge */
        .tab-content {
            overflow: visible !important;
        }
        
        #stages-tab {
            overflow: visible !important;
        }

        /* Solo la lista de etapas debe tener scroll, no todo el tab */
        .agents-sidebar .stages-list {
            overflow-y: auto;
            overflow-x: visible;
            flex: 1;
            min-height: 0;
            /* Permitir scroll independiente sin bloquear el scroll principal */
            max-height: calc(100vh - 300px);
            display: flex;
            flex-direction: column;
            gap: 8px; /* Mismo gap que .agents-list */
            margin-top: 0;
            padding-bottom: 24px; /* Padding extra al final para que el scroll llegue hasta el final */
            /* Scroll UBITS */
            scrollbar-width: thin;
            scrollbar-color: var(--ubits-fg-1-low) transparent;
        }
        
        /* Scroll UBITS para WebKit - stages-list */
        .agents-sidebar .stages-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .agents-sidebar .stages-list::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .agents-sidebar .stages-list::-webkit-scrollbar-thumb {
            background: var(--ubits-fg-1-low);
            border-radius: 3px;
        }
        
        .agents-sidebar .stages-list::-webkit-scrollbar-thumb:hover {
            background: var(--ubits-fg-1-medium);
        }
        
        /* Spacer al final de las listas de biblioteca */
        .library-scroll-spacer {
            height: 24px;
            flex-shrink: 0;
            width: 100%;
        }

        /* Lista de agentes también con scroll solo en la lista */
        .agents-sidebar .agents-list {
            overflow-y: auto;
            overflow-x: visible;
            flex: 1;
            min-height: 0;
            max-height: calc(100vh - 300px);
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-bottom: 24px; /* Padding extra al final para que el scroll llegue hasta el final */
            /* Scroll UBITS */
            scrollbar-width: thin;
            scrollbar-color: var(--ubits-fg-1-low) transparent;
        }
        
        /* Scroll UBITS para WebKit - agents-list */
        .agents-sidebar .agents-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .agents-sidebar .agents-list::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .agents-sidebar .agents-list::-webkit-scrollbar-thumb {
            background: var(--ubits-fg-1-low);
            border-radius: 3px;
        }
        
        .agents-sidebar .agents-list::-webkit-scrollbar-thumb:hover {
            background: var(--ubits-fg-1-medium);
        }
        
        /* Controles de etapas - fijos arriba del tab */
        .stages-controls-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            width: 100%;
            flex-wrap: wrap;
            position: relative;
            overflow: visible !important;
            flex-shrink: 0; /* No se comprime */
        }
        
        /* Search input wrapper para etapas */
        .search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            flex: 1;
            min-width: 150px;
        }

        .search-icon {
            position: absolute;
            left: 12px;
            color: var(--ubits-fg-1-medium);
            font-size: 14px;
            z-index: 2;
            pointer-events: none;
        }

        .search-input {
            width: 100%;
            padding: 10px 12px 10px 36px;
            border: 1px solid var(--ubits-border-1);
            border-radius: 6px;
            background: var(--ubits-bg-1);
            color: var(--ubits-fg-1-high);
            font-family: 'Noto Sans', sans-serif;
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s ease;
            box-sizing: border-box;
        }

        .search-input:focus {
            border-color: var(--ubits-accent-brand);
        }

        .clear-search-icon {
            position: absolute;
            right: 8px;
            background: none;
            border: none;
            color: var(--ubits-fg-1-low);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .clear-search-icon:hover {
            background: var(--ubits-bg-2);
            color: var(--ubits-fg-1-high);
        }

        /* Botón crear etapa */
        .create-stage-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--ubits-bg-1);
            border: 1px solid var(--ubits-border-1);
            border-radius: 6px;
            color: var(--ubits-fg-1-high);
            font-family: 'Noto Sans', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .create-stage-btn:hover {
            background: var(--ubits-bg-2);
            border-color: var(--ubits-accent-brand);
        }

        .create-stage-btn i {
            font-size: 12px;
        }
        
        /* Dropdown de categorías */
        #stageCategoryFilterContainer {
            position: relative;
            width: auto;
            min-width: auto;
            max-width: none;
        }
        
        .category-filter-dropdown {
            position: relative;
            display: inline-block;
            overflow: visible !important;
        }
        
        .category-filter-button {
            position: relative;
            overflow: visible !important;
        }
        
        .category-filter-button.ubits-button--active {
            background: var(--ubits-button-active-bg) !important;
            color: var(--ubits-accent-brand) !important;
            border: 1px solid transparent !important;
        }
        
        .category-filter-button.ubits-button--active:hover:not(:disabled) {
            background: var(--ubits-button-active-bg) !important;
            color: var(--ubits-accent-brand) !important;
        }
        
        .category-filter-button.ubits-button--active i {
            color: var(--ubits-accent-brand) !important;
        }
        
        /* Asegurar que el badge no se corte */
        .category-filter-dropdown {
            position: relative;
            display: inline-block;
            overflow: visible !important;
        }
        
        .category-filter-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            display: inline-flex !important;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0;
            background: var(--ubits-button-badge) !important;
            color: #ffffff !important;
            border-radius: 50%;
            font-size: 10px;
            font-weight: 600;
            font-family: 'Noto Sans', sans-serif;
            line-height: 18px;
            flex-shrink: 0;
            z-index: 10 !important;
            box-shadow: 0 0 0 2px var(--ubits-bg-1);
            overflow: visible !important;
            white-space: nowrap;
            box-sizing: border-box;
            text-align: center;
        }
        
        .category-filter-badge,
        .category-filter-badge *,
        .category-filter-badge::before,
        .category-filter-badge::after {
            color: #ffffff !important;
        }
        
        /* Forzar color blanco en todos los casos */
        .category-filter-button .category-filter-badge {
            color: #ffffff !important;
        }
        
        .category-filter-button.ubits-button--active .category-filter-badge {
            color: #ffffff !important;
        }
        
        /* Para números de dos dígitos, ajustar ancho y hacer más ovalado */
        .category-filter-badge.badge-double-digit {
            min-width: 20px !important;
            width: auto !important;
            padding: 0 5px !important;
            border-radius: 9px !important;
        }
        
        .category-filter-dropdown-menu {
            position: fixed;
            min-width: 280px;
            max-width: 320px;
            background: var(--ubits-bg-1);
            border: 1px solid var(--ubits-border-1);
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
            z-index: 10000;
            display: none;
            flex-direction: column;
            padding: 4px;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .category-filter-dropdown-menu.show {
            display: flex;
        }
        
        .category-filter-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s ease;
            font-family: 'Noto Sans', sans-serif;
            font-size: 14px;
            line-height: 1.5;
            color: var(--ubits-fg-1-high);
            user-select: none;
            margin: 0;
        }
        
        .category-filter-item:hover {
            background: var(--ubits-bg-2);
        }
        
        .category-filter-item input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
            width: 18px;
            height: 18px;
            min-width: 18px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            border: 2px solid var(--ubits-border-1);
            border-radius: 4px;
            background: var(--ubits-bg-1);
            position: relative;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .category-filter-item input[type="checkbox"]:hover {
            border-color: var(--ubits-accent-brand);
        }
        
        .category-filter-item input[type="checkbox"]:checked {
            border-color: var(--ubits-accent-brand);
            background: var(--ubits-accent-brand);
        }
        
        .category-filter-item input[type="checkbox"]:checked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 4px;
            height: 8px;
            border: solid white;
            border-width: 0 2px 2px 0;
        }

        /* Empty state para etapas */
        .empty-stages-visual {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 48px 24px;
            text-align: center;
            gap: 16px;
        }

        .empty-stages-visual .empty-icon {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: var(--ubits-bg-2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--ubits-fg-1-low);
        }

        .empty-stages-visual .empty-icon i {
            font-size: 24px;
        }

        .empty-stages-visual .empty-text {
            font-family: 'Noto Sans', sans-serif;
            font-size: 14px;
            color: var(--ubits-fg-1-medium);
            margin: 0;
        }

        /* Estilos para items de etapas en la lista */
        #stagesList .stage-item {
            display: flex;
            flex-direction: column;
            padding: 12px;
            background: var(--ubits-bg-1);
            border: 1px solid var(--ubits-border-1);
            border-radius: 6px;
            cursor: grab;
            transition: all 0.2s ease;
            font-family: 'Noto Sans', sans-serif;
            overflow: visible;
            position: relative;
        }

        #stagesList .stage-item:hover {
            background: var(--ubits-bg-2);
            border-color: var(--ubits-accent-brand);
        }

        #stagesList .stage-item:active {
            cursor: grabbing;
        }

        #stagesList .stage-item .stage-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0;
            border-bottom: none;
            width: 100%;
        }
        
        #stagesList .stage-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #stagesList .stage-name {
            font-size: 14px;
            font-weight: 500;
            color: var(--ubits-fg-1-high);
            margin: 0;
        }

        #stagesList .stage-category {
            font-size: 12px;
            color: var(--ubits-fg-1-medium);
            margin: 0;
        }

        #stagesList .stage-actions {
            display: flex;
            gap: 4px;
            opacity: 1;
            align-items: center;
        }
        
        .stage-menu {
            position: relative;
            overflow: visible;
        }
        
        .stage-menu-dropdown {
            position: fixed;
            background: var(--ubits-bg-1);
            border: 1px solid var(--ubits-border-1);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            min-width: 160px;
            padding: 4px;
            z-index: 10000;
            display: none;
            opacity: 0;
            transform: translateY(-8px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            overflow: visible;
        }
        
        .stage-menu-dropdown.show {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }
        
        .stage-menu-item {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Noto Sans', sans-serif;
            font-size: 13px;
            color: var(--ubits-fg-1-high);
            text-align: left;
            transition: background 0.15s ease;
        }
        
        .stage-menu-item:hover {
            background: var(--ubits-bg-2);
        }
        
        .stage-menu-item i {
            font-size: 14px;
            color: var(--ubits-fg-1-medium);
        }
        
        .stage-menu-item--danger {
            color: var(--ubits-feedback-accent-error);
        }
        
        .stage-menu-item--danger i {
            color: var(--ubits-feedback-accent-error);
        }
        
        .stage-menu-item--danger:hover {
            background: var(--ubits-feedback-bg-error-subtle);
        }

        /* Board principal */
        .board-main {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            overflow-y: visible;
        }

        .agents-title {
            font-family: 'Noto Sans', sans-serif;
            font-size: 18px;
            font-weight: 600;
            color: var(--ubits-fg-1-high);
            margin: 0;
            line-height: 1.2;
        }
        
        .agents-description-main {
            font-family: 'Noto Sans', sans-serif;
            font-size: 14px;
            color: var(--ubits-fg-1-medium);
            margin: 0;
            line-height: 1.4;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .agents-header-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 16px;
            flex-shrink: 0; /* No se comprime, queda fijo arriba */
        }

        /* Tabs del sidebar */
        .sidebar-tabs {
            display: flex;
            background: var(--ubits-bg-2);
            border-radius: 6px;
            padding: 4px;
        }

        .tab-button {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 12px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: var(--ubits-fg-1-medium);
            font-family: 'Noto Sans', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tab-button:hover {
            background: var(--ubits-bg-3);
            color: var(--ubits-fg-1-high);
        }

        .tab-button.active {
            background: var(--ubits-bg-1);
            color: var(--ubits-fg-1-high);
            font-weight: 600;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .tab-button i {
            font-size: 12px;
        }

        /* Contenido de tabs */
        .tab-content {
            display: none;
            overflow-x: visible;
            overflow-y: visible;
            position: relative;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
            gap: 16px;
            flex: 1;
            min-height: 0;
            overflow-y: visible; /* Sin scroll en el tab, solo en la lista */
            overflow-x: visible;
        }

        .agents-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .agent-item {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 12px;
            background: var(--ubits-bg-1);
            border: 1px solid var(--ubits-border-1);
            border-radius: 6px;
            cursor: grab;
            transition: all 0.2s ease;
            font-family: 'Noto Sans', sans-serif;
        }

        .agent-item:hover {
            background: var(--ubits-bg-3);
            border-color: var(--ubits-accent-brand);
        }

        .agent-item:active {
            cursor: grabbing;
        }

        .agent-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .agent-header {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: space-between;
        }
        
        .agent-title-section {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 0;
        }

        .agent-icon {
            width: 16px;
            height: 16px;
            color: var(--ubits-fg-1-medium);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .agent-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--ubits-fg-1-high);
        }

        .agent-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .agent-help {
            font-size: 12px;
            color: var(--ubits-fg-1-medium);
            line-height: 1.3;
            margin-left: 0;
            margin-top: 8px;
        }

        /* Empty state para agentes */
        .empty-stages-visual {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            text-align: center;
            margin-top: 0;
        }

        .empty-stages-visual .empty-icon {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: var(--ubits-bg-2);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 16px;
        }

        .empty-stages-visual .empty-icon i {
            font-size: 24px;
            color: var(--ubits-fg-1-medium);
        }

        .empty-stages-visual .empty-text {
            margin: 0 0 20px 0;
            font-size: 14px;
            font-weight: 500;
            color: var(--ubits-fg-1-medium);
            font-family: 'Noto Sans', sans-serif;
        }

        /* ========================================
           DRAWERS PARA CONFIGURACIÓN
           ======================================== */

        /* Drawer para gestionar pruebas psicotécnicas */
        .psychometric-tests-drawer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            display: none;
        }
        
        .psychometric-tests-drawer.active {
            display: flex;
            flex-direction: row;
            align-items: stretch;
        }
        
        .drawer-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            z-index: 10000;
        }
        
        .drawer-content {
            position: fixed;
            right: 0;
            top: 0;
            width: 480px;
            max-width: 90vw;
            height: 100%;
            background: var(--ubits-bg-1);
            box-shadow: -4px 0 16px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            z-index: 10001;
            animation: slideInRight 0.3s ease;
            pointer-events: auto;
        }
        
        .drawer-content * {
            pointer-events: auto;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
            }
            to {
                transform: translateX(0);
            }
        }
        
        .drawer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 24px;
            border-bottom: 1px solid var(--ubits-border-1);
        }
        
        .drawer-title {
            font-family: 'Noto Sans', sans-serif;
            font-size: 18px;
            font-weight: 600;
            color: var(--ubits-fg-1-high);
            margin: 0;
        }
        
        .drawer-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }
        
        .drawer-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--ubits-border-1);
            background: var(--ubits-bg-1);
        }
        
        .drawer-footer:has(.drawer-footer-actions:empty) {
            display: none;
        }
        
        .drawer-footer-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            align-items: center;
            width: 100%;
        }
        
        .tests-list {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
        }
        
        .test-item {
            background: transparent;
            border: 1px solid var(--ubits-border-1);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .test-item-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .test-item-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .test-item-title {
            font-family: 'Noto Sans', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: var(--ubits-fg-1-high);
        }
        
        .test-item-subtitle {
            font-family: 'Noto Sans', sans-serif;
            font-size: 12px;
            color: var(--ubits-fg-1-medium);
        }
        
        .test-item-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .test-item-fields {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .test-item-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .test-item-field label {
            font-family: 'Noto Sans', sans-serif;
            font-size: 12px;
            font-weight: 400;
            color: var(--ubits-fg-1-medium);
        }
        
        .test-item-field-value {
            font-family: 'Noto Sans', sans-serif;
            font-size: 13px;
            color: var(--ubits-fg-1-high);
        }
        
        .test-form {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }
        
        .test-form-fields {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .test-form-field {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .test-form-field label {
            font-family: 'Noto Sans', sans-serif;
            font-size: 13px;
            font-weight: 400;
            color: var(--ubits-fg-1-medium);
        }
        
        .test-form-field-label-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .test-form-field-label-wrapper span {
            font-family: 'Noto Sans', sans-serif;
            font-size: 13px;
            font-weight: 400;
            color: var(--ubits-fg-1-medium);
        }
        
        .test-form-info-btn {
            flex-shrink: 0;
        }

        /* Drawer para configurar entrevista Serena AI */
        .serena-config-drawer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            display: none;
        }
        
        .serena-config-drawer.active {
            display: flex;
            flex-direction: row;
            align-items: stretch;
        }
        
        .serena-config-content {
            display: flex;
            flex-direction: column;
            gap: 32px;
        }
        
        .serena-section {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .serena-section-title {
            font-family: 'Noto Sans', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: var(--ubits-fg-1-high);
            margin: 0;
        }
        
        .serena-section-description {
            font-family: 'Noto Sans', sans-serif;
            font-size: 13px;
            color: var(--ubits-fg-1-medium);
            margin: 0;
            line-height: 1.5;
        }
        
        .interview-type-cards {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .interview-type-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border: 2px solid var(--ubits-border-1);
            border-radius: 8px;
            background: var(--ubits-bg-1);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .interview-type-card:hover {
            border-color: var(--ubits-accent-brand);
            background: var(--ubits-accent-brand-subtle);
        }
        
        .interview-type-card.selected {
            border-color: var(--ubits-accent-brand);
            background: var(--ubits-accent-brand-subtle);
        }
        
        .interview-type-card .config-radio-label {
            margin: 0;
            padding: 0;
            flex-shrink: 0;
        }
        
        .interview-type-card .config-radio-label span {
            display: none;
        }
        
        .interview-type-card-content {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .interview-type-card-icon {
            font-size: 18px;
            color: var(--ubits-fg-1-medium);
        }
        
        .interview-type-card.selected .interview-type-card-icon {
            color: var(--ubits-accent-brand);
        }
        
        .interview-type-card-label {
            font-family: 'Noto Sans', sans-serif;
            font-size: 13px;
            font-weight: 600;
            color: var(--ubits-fg-1-high);
        }
        
        .interview-type-card.selected .interview-type-card-label {
            color: var(--ubits-accent-brand);
        }
        
        .serena-voice-preview {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px;
            border: 1px solid var(--ubits-border-1);
            border-radius: 10px;
            background: var(--ubits-bg-1);
            margin-top: 12px;
        }
        
        .serena-voice-preview-icon-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            border-radius: 10px;
            background: var(--ubits-accent-brand-subtle);
            flex-shrink: 0;
        }
        
        .serena-voice-preview-icon {
            font-size: 20px;
            color: var(--ubits-accent-brand);
        }
        
        .serena-voice-preview-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
        }
        
        .serena-voice-preview-name {
            font-family: 'Noto Sans', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: var(--ubits-fg-1-high);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .serena-voice-preview-flag {
            font-size: 18px;
        }
        
        .serena-voice-preview-hint {
            font-family: 'Noto Sans', sans-serif;
            font-size: 11px;
            color: var(--ubits-fg-1-medium);
        }
        
        .serena-voice-preview-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }
        
        .serena-config-fields {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .serena-config-field {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .serena-config-field-label-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .serena-config-field-label {
            font-family: 'Noto Sans', sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: var(--ubits-fg-1-high);
            margin: 0;
        }

        /* Board Container - Igual que en el editor */
        .board-container {
            flex: 1;
            background: var(--ubits-bg-1);
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 16px;
            padding-bottom: 48px; /* Padding extra al final para que el scroll llegue hasta el final */
            height: fit-content;
            box-sizing: border-box;
            overflow-x: hidden !important;
            /* Scroll interno solo para el tablero de flujo */
            overflow-y: auto;
            min-width: 0;
            width: 100%;
            max-width: none;
            max-height: calc(100vh - 240px); /* Ajustado para dar más espacio */
            transition: all 0.2s ease;
            /* Scroll UBITS */
            scrollbar-width: thin;
            scrollbar-color: var(--ubits-fg-1-low) transparent;
        }
        
        /* Scroll UBITS para WebKit (Chrome, Safari, Edge) */
        .board-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .board-container::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .board-container::-webkit-scrollbar-thumb {
            background: var(--ubits-fg-1-low);
            border-radius: 3px;
        }
        
        .board-container::-webkit-scrollbar-thumb:hover {
            background: var(--ubits-fg-1-medium);
        }
        
        /* Spacer al final para asegurar que el scroll llegue hasta el final */
        .board-container > .board-scroll-spacer {
            height: 40px;
            flex-shrink: 0;
            width: 100%;
        }

        .board-container.drag-over {
            background: var(--ubits-bg-1);
            border: 2px dashed var(--ubits-feedback-accent-info);
        }

        /* Mantener fija la sección donde están los pasos (stepper) */
        .stepper-section {
            position: sticky;
            top: 0;
            z-index: 6;
        }

        /* Mantener fija la fila con selector de plantilla y notificaciones */
        /* Altura aproximada del stepper (80px) + gap (16px) = 96px */
        .sticky-config-section {
            position: sticky;
            top: calc(80px + 16px); /* Altura del stepper + gap */
            z-index: 4;
        }

        /* Mantener fijos los contenedores de biblioteca y flujo del candidato */
        /* Altura del stepper (80px) + gap (16px) + altura de config (120px) + gap (16px) = 232px */
        .template-flow-section {
            position: sticky;
            top: calc(80px + 16px + 120px + 16px); /* Altura stepper + gap + altura config + gap */
            z-index: 3;
            width: 100%;
            max-width: 100%;
            min-width: 0;
        }

        /* Esta página no debe tener scroll general, solo interno en los paneles */
        html,
        body {
            height: 100%;
            overflow: hidden !important;
            position: fixed;
            width: 100%;
        }

        /* Asegurar que main-content y content-area no causen scroll */
        .main-content {
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            width: calc(100vw - 143px - 24px) !important;
            max-width: none !important;
        }
        
        /* Override más específico para pantallas grandes */
        @media (min-width: 1440px) {
            .dashboard-container .main-content,
            body .main-content,
            html body .main-content {
                width: calc(100vw - 143px - 24px) !important;
                max-width: none !important;
                margin-left: 143px !important;
                margin-right: 24px !important;
            }
        }
        
        /* Override para todas las resoluciones */
        .dashboard-container .main-content,
        body .main-content {
            width: calc(100vw - 143px - 24px) !important;
            max-width: none !important;
        }

        .content-area {
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 100%;
            min-width: 0;
            box-sizing: border-box;
        }

        .content-sections {
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .stages-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 200px;
            min-width: 0;
            overflow-x: hidden;
            overflow-y: auto;
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
        }

        .stage-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--ubits-bg-2);
            border: 1px solid var(--ubits-border-1);
            border-radius: 8px;
            transition: all 0.2s ease;
            position: relative;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            min-width: 0;
            overflow: hidden;
        }
        
        /* Quitar fondo gris de las cards en modo vista */
        .board-container.view-mode .stage-item,
        .board-container.view-mode .agent-stage-item,
        .board-container.view-mode .custom-stage-item {
            background: transparent;
            border: 1px solid var(--ubits-border-1);
        }

        .agent-stage-item:hover {
            background: var(--ubits-bg-2);
            border-color: var(--ubits-border-1);
        }

        .stage-number {
            width: 32px !important;
            height: 32px !important;
            min-width: 32px !important;
            max-width: 32px !important;
            flex-shrink: 0 !important;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--ubits-bg-1);
            color: var(--ubits-fg-1-high);
            border: 1px solid var(--ubits-border-1);
            border-radius: 50% !important;
            font-family: 'Noto Sans', sans-serif;
            font-size: 14px;
            font-weight: 600;
            box-sizing: border-box;
        }

        .stage-drag-handle {
            color: var(--ubits-fg-1-medium);
            font-size: 14px;
            flex-shrink: 0;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .stage-drag-handle.editing-mode {
            opacity: 1;
            pointer-events: auto;
        }

        .stage-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 0;
        }

        .stage-content .stage-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0;
            border-bottom: none;
            min-width: 0;
        }

        .stage-title-section {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-width: 0;
        }

        .stage-name {
            font-family: 'Noto Sans', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: var(--ubits-fg-1-high);
            margin: 0;
        }

        .stage-name h4 {
            margin: 0;
        }

        .stage-category-badge {
            font-family: 'Noto Sans', sans-serif;
            font-size: 12px;
            color: var(--ubits-fg-1-medium);
            background: transparent;
            padding: 0;
            border: none;
            margin: 0;
        }

        .stage-description {
            font-family: 'Noto Sans', sans-serif;
            font-size: 13px;
            color: var(--ubits-fg-1-medium);
            line-height: 1.5;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--ubits-border-1);
        }

        .stage-config-summary {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 8px;
            padding-top: 8px;
        }

        .config-summary-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--ubits-fg-1-medium);
        }

        .config-summary-label {
            font-weight: 400;
        }

        .config-summary-value {
            font-weight: 600;
            color: var(--ubits-fg-1-high);
        }

        .stage-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            align-items: center;
            flex-shrink: 0;
            min-width: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .stage-actions.editing-mode {
            opacity: 1;
            pointer-events: auto;
        }

        /* Agent Stage Config */
        .agent-stage-config {
            width: 100%;
            box-sizing: border-box;
            min-width: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .agent-stage-divider {
            height: 1px;
            background: var(--ubits-border-1);
            margin: 12px 0;
        }

        .config-field {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 4px;
            width: 100%;
        }

        .config-field-radio {
            margin-bottom: 16px;
            margin-top: 8px;
        }

        .config-label {
            font-family: 'Noto Sans', sans-serif;
            font-size: 12px;
            font-weight: 400;
            color: var(--ubits-fg-1-medium);
            white-space: nowrap;
            width: 200px;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }

        .config-info-btn {
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: var(--ubits-fg-1-medium);
            transition: color 0.2s ease;
            flex-shrink: 0;
        }

        .config-info-btn:hover {
            color: var(--ubits-accent-brand);
        }

        .config-info-btn i {
            font-size: 12px;
        }

        .tooltip.agent-info-tooltip {
            white-space: normal;
            max-width: 400px;
            min-width: 250px;
            padding: 12px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            box-sizing: border-box;
            max-width: min(400px, calc(100vw - 24px));
        }

        .tooltip.agent-info-tooltip::before {
            left: -6px;
        }
        
        /* Tooltip en board (paso del proceso) - alineado a la derecha */
        .board-container .tooltip.agent-info-tooltip::before {
            left: auto;
            right: -6px;
        }
        
        .tooltip.config-info-tooltip {
            white-space: normal;
            max-width: 300px;
            min-width: 200px;
            padding: 10px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            box-sizing: border-box;
            max-width: min(300px, calc(100vw - 24px));
        }
        
        .tooltip.config-info-tooltip::before {
            left: 50%;
            transform: translateX(-50%);
            bottom: -6px;
            top: auto;
        }

        .config-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
        }

        .config-input {
            width: 100px;
            max-width: 100px;
            padding: 6px 10px;
            border: 1px solid var(--ubits-border-1);
            border-radius: 6px;
            background: var(--ubits-bg-2);
            color: var(--ubits-fg-1-high);
            font-family: 'Noto Sans', sans-serif;
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s ease;
            box-sizing: border-box;
        }

        .config-input:focus {
            border-color: var(--ubits-accent-brand);
        }

        .config-suffix {
            font-family: 'Noto Sans', sans-serif;
            font-size: 12px;
            color: var(--ubits-fg-1-medium);
            white-space: nowrap;
        }

        .config-radio-group {
            display: flex;
            align-items: center;
            gap: 24px;
            min-width: 120px;
            flex: 1;
        }

        .config-radio-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-family: 'Noto Sans', sans-serif;
            font-size: 13px;
            color: var(--ubits-fg-1-high);
            user-select: none;
            padding: 4px 0;
        }

        .config-radio-label input[type="radio"] {
            margin: 0;
            cursor: pointer;
            width: 18px;
            height: 18px;
            appearance: none;
            border: 2px solid var(--ubits-border-1);
            border-radius: 50%;
            background: var(--ubits-bg-1);
            position: relative;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .config-radio-label input[type="radio"]:hover {
            border-color: var(--ubits-accent-brand);
        }

        .config-radio-label input[type="radio"]:checked {
            border-color: var(--ubits-accent-brand);
            background: var(--ubits-accent-brand);
        }

        .config-radio-label input[type="radio"]:checked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--ubits-bg-1);
        }

        .config-input-container {
            flex: 1;
            min-width: 0;
            width: 100%;
            max-width: 100%;
            position: relative;
            display: block;
        }
        
        /* Asegurar que los inputs UBITS dentro de config-input-container se muestren */
        .config-input-container .ubits-input {
            width: 100%;
            max-width: 100%;
        }
        
        .test-form {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        /* Board Header Section */
        .board-header-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 8px;
        }

        .board-header-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }

        .board-header-title-wrapper {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .board-header-title {
            font-family: 'Noto Sans', sans-serif;
            font-size: 18px;
            font-weight: 600;
            color: var(--ubits-fg-1-high);
            margin: 0;
            line-height: 1.2;
        }
        
        .board-header-description {
            font-family: 'Noto Sans', sans-serif;
            font-size: 14px;
            font-weight: 400;
            color: var(--ubits-fg-1-medium);
            margin: 0;
            line-height: 1.5;
        }

        .board-empty-title {
            font-family: 'Noto Sans', sans-serif;
            font-size: 18px;
            font-weight: 600;
            color: var(--ubits-fg-1-high);
            margin: 0;
            line-height: 1.2;
            flex: 1;
        }

        .board-empty-instruction {
            font-family: 'Noto Sans', sans-serif;
            font-size: 14px;
            color: var(--ubits-fg-1-medium);
            margin: 0;
            line-height: 1.4;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        /* Board Drop Slots */
        .board-drop-slots {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: opacity 0.3s ease, max-height 0.3s ease;
        }

        .board-drop-slots.editing-mode {
            opacity: 1;
            max-height: 200px;
        }

        .board-drop-slot {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            min-height: 48px;
            max-height: 48px;
            border: 2px dashed var(--ubits-border-1);
            border-radius: 8px;
            background: var(--ubits-bg-2);
            transition: all 0.2s ease;
            cursor: default;
        }

        /* Quitar hover - solo cambiar cuando está en drag-over */
        .board-drop-slot:hover {
            /* Sin cambios en hover - mantener estilos por defecto */
        }

        .board-container.drag-over .board-drop-slot {
            border-color: var(--ubits-feedback-accent-info);
            background: var(--ubits-feedback-bg-info-subtle);
        }

        .board-drop-slot.drag-over {
            border-color: var(--ubits-feedback-accent-info);
            background: var(--ubits-feedback-bg-info-subtle);
            border-style: solid;
        }

        .slot-number {
            width: 24px !important;
            height: 24px !important;
            min-width: 24px !important;
            max-width: 24px !important;
            flex-shrink: 0 !important;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--ubits-bg-1);
            color: var(--ubits-fg-1-high);
            border: 1px solid var(--ubits-border-1);
            border-radius: 50% !important;
            font-family: 'Noto Sans', sans-serif;
            font-size: 12px;
            font-weight: 600;
            box-sizing: border-box;
        }

        .slot-placeholder {
            flex: 1;
            height: 32px;
            border-radius: 4px;
            background: transparent;
            min-width: 0;
            max-width: 100%;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--ubits-fg-1-medium);
            font-size: 13px;
            text-align: center;
            padding: 0 8px;
            font-family: 'Noto Sans', sans-serif;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .stepper-container {
                margin: 12px;
            }
            
            .stepper {
                flex-wrap: wrap;
                gap: 16px;
            }
            
            .stepper-item {
                flex: none;
                min-width: 80px;
            }
            
        }
    </style>
</head>
<body data-theme="light">
    <div class="dashboard-container">
        <div class="tooltip" id="tooltip"></div>
        
        <!-- Sidebar Container -->
        <div id="sidebar-container"></div>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Content Area -->
            <div class="content-area">
                <!-- Content wrapper con secciones de widgets -->
                <div class="content-sections">
                    <!-- Sección 1: Stepper -->
                    <div class="section-single stepper-section">
                        <div class="widget-stepper">
                            <!-- Desktop Stepper -->
                            <div class="stepper">
                                <div class="stepper-item completed">
                                    <div class="stepper-circle">
                                        <i class="far fa-check stepper-icon"></i>
                                    </div>
                                    <div class="stepper-label">Información básica</div>
                                </div>
                                <div class="stepper-item active">
                                    <div class="stepper-circle">2</div>
                                    <div class="stepper-label">Flujo del candidato</div>
                                </div>
                                <div class="stepper-item" id="stepper-step-3" style="display: none;">
                                    <div class="stepper-circle">3</div>
                                    <div class="stepper-label">Preguntas Serena IA</div>
                                </div>
                                <div class="stepper-item">
                                    <div class="stepper-circle">4</div>
                                    <div class="stepper-label">Añade miembros</div>
                                </div>
                                <div class="stepper-item">
                                    <div class="stepper-circle">
                                        <i class="far fa-paper-plane stepper-icon"></i>
                                    </div>
                                    <div class="stepper-label">Publícala</div>
                                </div>
                            </div>
                            
                            <!-- Mobile Stepper -->
                            <div class="mobile-stepper">
                                <div class="mobile-progress-circle" data-progress="40">
                                    <svg>
                                        <circle class="mobile-progress-bg" cx="24" cy="24" r="22"></circle>
                                        <circle class="mobile-progress-fill" cx="24" cy="24" r="22"></circle>
                                    </svg>
                                    <span>2/5</span>
                                </div>
                                <div class="mobile-stepper-text">
                                    <div class="mobile-current-step">Flujo del candidato</div>
                                    <button class="ubits-button ubits-button--primary ubits-button--sm mobile-next-button">
                                        <span>Siguiente</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Sección 2: Configuración (2 columnas) -->
                    <div class="section-dual sticky-config-section">
                        <!-- Widget: Selector de plantilla -->
                        <div class="widget-template-selector">
                            <div class="selector-header">
                                <div class="selector-icon">
                                    <i class="far fa-square-list"></i>
                                </div>
                                <div class="selector-title">Seleccionar plantilla</div>
                            </div>
                            <div id="template-input-container"></div>
                        </div>

                        <!-- Widget: Notificaciones -->
                        <div class="widget-notifications">
                            <div class="config-card-header">
                                <div class="config-card-title">
                                    <div class="config-card-icon">
                                        <i class="far fa-envelope"></i>
                                    </div>
                                    <div class="config-card-name">Activar notificaciones automáticas de rechazo</div>
                                </div>
                                <label class="switch">
                                    <input type="checkbox" checked>
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="config-fields">
                                <div id="days-input-container"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Sección 3: Flujo de la plantilla seleccionada -->
                    <div class="section-dual template-flow-section" id="template-flow-section" style="display: flex;">
                        <!-- Biblioteca (solo visible en modo edición) -->
                        <div class="widget-library" id="library-widget" style="display: flex;">
                            <div class="agents-sidebar" id="agents-sidebar">
                                <!-- Título y descripción de la sección -->
                                <div class="agents-header-section">
                                    <h3 class="agents-title">Biblioteca de etapas y etapas con IA</h3>
                                    <p class="agents-description-main">Crea y gestiona las etapas y etapas con IA que podrás usar en el flujo del candidato.</p>
                                </div>
                                
                                <!-- Tabs -->
                                <div class="sidebar-tabs">
                                    <button class="tab-button active" data-tab="stages" onclick="switchTab('stages')">
                                        <i class="far fa-timeline-arrow"></i>
                                        <span>Etapas</span>
                                    </button>
                                    <button class="tab-button" data-tab="agents" onclick="switchTab('agents')">
                                        <i class="far fa-users"></i>
                                        <span>Etapas con IA</span>
                                    </button>
                                </div>
                                
                                <!-- Tab Etapas -->
                                <div class="tab-content active" id="stages-tab">
                                    <!-- Contenedor de controles en una sola línea -->
                                    <div class="stages-controls-row">
                                        <!-- Buscador de etapas -->
                                        <div class="search-input-wrapper" id="stageSearchWrapper">
                                            <i class="far fa-search search-icon"></i>
                                            <input 
                                                type="text" 
                                                id="stageSearch" 
                                                placeholder="Buscar etapas" 
                                                class="search-input"
                                                aria-label="Buscar etapas"
                                            >
                                            <button type="button" id="clearStageSearch" class="clear-search-icon" style="display: none;">
                                                <i class="far fa-times"></i>
                                            </button>
                                        </div>
                                        
                                        <!-- Filtro de categorías -->
                                        <div id="stageCategoryFilterContainer"></div>
                                        
                                        <!-- Botón crear etapa (al final) -->
                                        <button class="create-stage-btn" id="createStageBtn" onclick="openCreateStageModal();">
                                            <i class="far fa-plus"></i>
                                            <span>Crear etapa</span>
                                        </button>
                                    </div>
                                    
                                    <!-- Empty state para búsqueda/filtrado -->
                                    <div class="empty-stages-visual" id="stagesEmptyState" style="display: none;">
                                        <div class="empty-icon">
                                            <i class="far fa-search"></i>
                                        </div>
                                        <p class="empty-text" id="stagesEmptyStateText">No se encontraron etapas</p>
                                    </div>
                                    
                                    <!-- Lista de etapas -->
                                    <div class="stages-list" id="stagesList">
                                        <!-- Las etapas se cargarán dinámicamente -->
                                    </div>
                                </div>
                                
                                <!-- Tab Etapas con IA -->
                                <div class="tab-content" id="agents-tab">
                                    <div class="agents-list" id="agentsList">
                                        <!-- Los agentes se cargarán dinámicamente -->
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Flujo del candidato -->
                        <div class="widget-template-flow">
                            <div class="board-container">
                                <div class="stages-container" id="template-flow-container">
                                    <!-- Las etapas se cargarán dinámicamente -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Tab Bar Container -->
    <div id="tab-bar-container"></div>

    <!-- Floating Menu Container -->
    <div id="floating-menu-reclutamiento-container"></div>
    
    <!-- Profile Menu Container -->
    <div id="profile-menu-container"></div>

    <!-- Toast Container -->
    <div id="ubits-toast-container"></div>

    <!-- Drawer para gestionar pruebas psicotécnicas -->
    <div class="psychometric-tests-drawer" id="psychometricTestsDrawer">
        <div class="drawer-overlay" onclick="handleDrawerOverlayClick(event)"></div>
        <div class="drawer-content" onclick="if(event.target === this) event.stopPropagation();">
            <div class="drawer-header">
                <h3 class="drawer-title" id="drawerTitle">Pruebas psicotécnicas</h3>
                <button class="ubits-button ubits-button--secondary ubits-button--sm ubits-button--icon-only" onclick="handleDrawerCloseButton(event); return false;" title="Cerrar">
                    <i class="far fa-times"></i>
                </button>
            </div>
            <div class="drawer-body">
                <div id="psychometricTestsList" class="tests-list">
                    <!-- Las pruebas se cargarán dinámicamente -->
                </div>
            </div>
            <div class="drawer-footer">
                <div class="drawer-footer-actions" id="drawerFooterActions">
                    <!-- Botones se cargarán dinámicamente -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Drawer para configurar entrevista Serena AI -->
    <div class="serena-config-drawer" id="serenaConfigDrawer">
        <div class="drawer-overlay" onclick="handleSerenaDrawerOverlayClick(event)"></div>
        <div class="drawer-content" onclick="if(event.target === this) event.stopPropagation();">
            <div class="drawer-header">
                <h3 class="drawer-title" id="serenaDrawerTitle">Configurar entrevista Serena</h3>
                <button class="ubits-button ubits-button--secondary ubits-button--sm ubits-button--icon-only" onclick="closeSerenaConfigDrawer(); return false;" title="Cerrar">
                    <i class="far fa-times"></i>
                </button>
            </div>
            <div class="drawer-body">
                <div id="serenaConfigContent" class="serena-config-content">
                    <!-- Contenido se cargará dinámicamente -->
                </div>
            </div>
            <div class="drawer-footer">
                <div class="drawer-footer-actions" id="serenaDrawerFooterActions">
                    <!-- Botones se cargarán dinámicamente -->
                </div>
            </div>
        </div>
    </div>

    <script src="components/sidebar-reclutamiento.js"></script>
    <script src="components/sub-nav.js"></script>
    <script src="components/tab-bar-reclutamiento.js"></script>
    <script src="components/floating-menu.js"></script>
    <script src="components/profile-menu.js"></script>
    <script src="components/input.js"></script>
    <script src="components/modal.js"></script>
    <script src="components/toast.js"></script>
    <script src="script.js"></script>
    <script>
        // Cargar componentes dinámicamente
        document.addEventListener('DOMContentLoaded', function() {
            loadSidebarReclutamiento('vacantes');
            loadTabBarReclutamiento('tab-bar-container');
            loadFloatingMenuReclutamiento('floating-menu-reclutamiento-container');
            loadProfileMenu('profile-menu-container');
            
            // Cargar etapas disponibles
            console.log('🔧 [DOMContentLoaded] Cargando etapas disponibles...');
            try {
                loadAvailableStages();
                console.log('✅ [DOMContentLoaded] Etapas disponibles cargadas');
            } catch (error) {
                console.error('❌ [DOMContentLoaded] Error al cargar etapas disponibles:', error);
            }
            
            // Asegurar que las plantillas por defecto existan
            const stored = localStorage.getItem('templates');
            if (stored) {
                const templates = JSON.parse(stored);
                const hasDefaultTemplates = templates.some(t => t.isDefault === true);
                if (!hasDefaultTemplates) {
                    console.log('📋 [DOMContentLoaded] Creando plantillas por defecto...');
                    const defaultTemplates = createDefaultTemplates();
                    templates.push(...defaultTemplates);
                    localStorage.setItem('templates', JSON.stringify(templates));
                    console.log('📋 [DOMContentLoaded] Plantillas por defecto creadas y guardadas');
                }
            } else {
                console.log('📋 [DOMContentLoaded] No hay plantillas. Creando plantillas por defecto...');
                const defaultTemplates = createDefaultTemplates();
                localStorage.setItem('templates', JSON.stringify(defaultTemplates));
                console.log('📋 [DOMContentLoaded] Plantillas por defecto creadas y guardadas');
            }
            
            // Activar vacantes en el floating menu
            setTimeout(() => {
                setActiveDirectLinkReclutamiento('vacantes');
            }, 500);
            
            // Crear inputs UBITS
            createTemplateSelect();
            createDaysInput();
            
            // El flujo vacío se inicializará automáticamente cuando se seleccione "Personalizada" en createTemplateSelect
            
            // Actualizar stepper inicialmente después de un pequeño delay para asegurar que el DOM esté listo
            setTimeout(() => {
                updateStepper();
            }, 500);

            // LOGS DE DEPURACIÓN DE SCROLL Y STICKY
            try {
                const body = document.body;
                const html = document.documentElement;
                const dashboard = document.querySelector('.dashboard-container');
                const mainContent = document.querySelector('.main-content');
                const contentArea = document.querySelector('.content-area');
                const stepperSection = document.querySelector('.stepper-section');
                const stickyConfig = document.querySelector('.sticky-config-section');
                const templateFlowSection = document.querySelector('.template-flow-section');
                const boardContainer = document.querySelector('.board-container');

                console.log('🔎 [Vacante Debug] ============================================');
                console.log('🔎 [Vacante Debug] ESTADOS INICIALES DE SCROLL Y STICKY');
                console.log('🔎 [Vacante Debug] ============================================');
                
                // HTML y Body
                console.log('\n📄 HTML:');
                console.log('  - overflowX:', getComputedStyle(html).overflowX);
                console.log('  - overflowY:', getComputedStyle(html).overflowY);
                console.log('  - scrollHeight:', html.scrollHeight, 'px');
                console.log('  - clientHeight:', html.clientHeight, 'px');
                console.log('  - ¿Tiene scroll?', html.scrollHeight > html.clientHeight ? '✅ SÍ' : '❌ NO');
                
                console.log('\n📄 BODY:');
                console.log('  - overflowX:', getComputedStyle(body).overflowX);
                console.log('  - overflowY:', getComputedStyle(body).overflowY);
                console.log('  - scrollHeight:', body.scrollHeight, 'px');
                console.log('  - clientHeight:', body.clientHeight, 'px');
                console.log('  - ¿Tiene scroll?', body.scrollHeight > body.clientHeight ? '✅ SÍ' : '❌ NO');
                
                // Contenedores principales
                if (dashboard) {
                    console.log('\n📦 .dashboard-container:');
                    console.log('  - overflowX:', getComputedStyle(dashboard).overflowX);
                    console.log('  - overflowY:', getComputedStyle(dashboard).overflowY);
                    console.log('  - scrollHeight:', dashboard.scrollHeight, 'px');
                    console.log('  - clientHeight:', dashboard.clientHeight, 'px');
                }
                
                if (mainContent) {
                    console.log('\n📦 .main-content:');
                    console.log('  - overflowX:', getComputedStyle(mainContent).overflowX);
                    console.log('  - overflowY:', getComputedStyle(mainContent).overflowY);
                    console.log('  - scrollHeight:', mainContent.scrollHeight, 'px');
                    console.log('  - clientHeight:', mainContent.clientHeight, 'px');
                }
                
                if (contentArea) {
                    console.log('\n📦 .content-area:');
                    console.log('  - overflowX:', getComputedStyle(contentArea).overflowX);
                    console.log('  - overflowY:', getComputedStyle(contentArea).overflowY);
                    console.log('  - scrollHeight:', contentArea.scrollHeight, 'px');
                    console.log('  - clientHeight:', contentArea.clientHeight, 'px');
                }
                
                // Secciones sticky
                if (stepperSection) {
                    const rect = stepperSection.getBoundingClientRect();
                    console.log('\n📌 .stepper-section (STICKY):');
                    console.log('  - position:', getComputedStyle(stepperSection).position);
                    console.log('  - top:', getComputedStyle(stepperSection).top);
                    console.log('  - z-index:', getComputedStyle(stepperSection).zIndex);
                    console.log('  - getBoundingClientRect().top:', rect.top, 'px');
                    console.log('  - ¿Está fijo?', getComputedStyle(stepperSection).position === 'sticky' ? '✅ SÍ' : '❌ NO');
                } else {
                    console.log('\n❌ .stepper-section: NO ENCONTRADO');
                }
                
                if (stickyConfig) {
                    const rect = stickyConfig.getBoundingClientRect();
                    console.log('\n📌 .sticky-config-section (STICKY):');
                    console.log('  - position:', getComputedStyle(stickyConfig).position);
                    console.log('  - top:', getComputedStyle(stickyConfig).top);
                    console.log('  - z-index:', getComputedStyle(stickyConfig).zIndex);
                    console.log('  - getBoundingClientRect().top:', rect.top, 'px');
                    console.log('  - ¿Está fijo?', getComputedStyle(stickyConfig).position === 'sticky' ? '✅ SÍ' : '❌ NO');
                } else {
                    console.log('\n❌ .sticky-config-section: NO ENCONTRADO');
                }
                
                if (templateFlowSection) {
                    const rect = templateFlowSection.getBoundingClientRect();
                    console.log('\n📌 .template-flow-section (STICKY):');
                    console.log('  - position:', getComputedStyle(templateFlowSection).position);
                    console.log('  - top:', getComputedStyle(templateFlowSection).top);
                    console.log('  - z-index:', getComputedStyle(templateFlowSection).zIndex);
                    console.log('  - getBoundingClientRect().top:', rect.top, 'px');
                    console.log('  - ¿Está fijo?', getComputedStyle(templateFlowSection).position === 'sticky' ? '✅ SÍ' : '❌ NO');
                } else {
                    console.log('\n❌ .template-flow-section: NO ENCONTRADO');
                }
                
                // Board container
                if (boardContainer) {
                    const boardRect = boardContainer.getBoundingClientRect();
                    console.log('\n📦 .board-container:');
                    console.log('  - overflowY:', getComputedStyle(boardContainer).overflowY);
                    console.log('  - maxHeight:', getComputedStyle(boardContainer).maxHeight);
                    console.log('  - scrollHeight:', boardContainer.scrollHeight, 'px');
                    console.log('  - clientHeight:', boardContainer.clientHeight, 'px');
                    console.log('  - width (CSS):', getComputedStyle(boardContainer).width);
                    console.log('  - maxWidth (CSS):', getComputedStyle(boardContainer).maxWidth);
                    console.log('  - getBoundingClientRect().width:', boardRect.width, 'px');
                    console.log('  - ¿Tiene scroll interno?', boardContainer.scrollHeight > boardContainer.clientHeight ? '✅ SÍ' : '❌ NO');
                }
                
                // LOGS DETALLADOS DE ANCHOS
                console.log('\n🔎 [Vacante Debug] ============================================');
                console.log('🔎 [Vacante Debug] ANÁLISIS DE ANCHOS');
                console.log('🔎 [Vacante Debug] ============================================');
                
                if (mainContent) {
                    const mainRect = mainContent.getBoundingClientRect();
                    console.log('\n📏 .main-content:');
                    console.log('  - width (CSS):', getComputedStyle(mainContent).width);
                    console.log('  - maxWidth (CSS):', getComputedStyle(mainContent).maxWidth);
                    console.log('  - getBoundingClientRect().width:', mainRect.width, 'px');
                    console.log('  - window.innerWidth:', window.innerWidth, 'px');
                    console.log('  - Diferencia:', (window.innerWidth - mainRect.width), 'px');
                }
                
                if (contentArea) {
                    const contentRect = contentArea.getBoundingClientRect();
                    console.log('\n📏 .content-area:');
                    console.log('  - width (CSS):', getComputedStyle(contentArea).width);
                    console.log('  - maxWidth (CSS):', getComputedStyle(contentArea).maxWidth);
                    console.log('  - getBoundingClientRect().width:', contentRect.width, 'px');
                }
                
                const contentSections = document.querySelector('.content-sections');
                if (contentSections) {
                    const sectionsRect = contentSections.getBoundingClientRect();
                    console.log('\n📏 .content-sections:');
                    console.log('  - width (CSS):', getComputedStyle(contentSections).width);
                    console.log('  - maxWidth (CSS):', getComputedStyle(contentSections).maxWidth);
                    console.log('  - getBoundingClientRect().width:', sectionsRect.width, 'px');
                }
                
                const widgetTemplateFlow = document.querySelector('.widget-template-flow');
                if (widgetTemplateFlow) {
                    const widgetRect = widgetTemplateFlow.getBoundingClientRect();
                    console.log('\n📏 .widget-template-flow:');
                    console.log('  - width (CSS):', getComputedStyle(widgetTemplateFlow).width);
                    console.log('  - maxWidth (CSS):', getComputedStyle(widgetTemplateFlow).maxWidth);
                    console.log('  - getBoundingClientRect().width:', widgetRect.width, 'px');
                }
                
                // Reutilizar templateFlowSection ya declarado arriba
                if (templateFlowSection) {
                    const flowSectionRect = templateFlowSection.getBoundingClientRect();
                    console.log('\n📏 .template-flow-section:');
                    console.log('  - width (CSS):', getComputedStyle(templateFlowSection).width);
                    console.log('  - maxWidth (CSS):', getComputedStyle(templateFlowSection).maxWidth);
                    console.log('  - getBoundingClientRect().width:', flowSectionRect.width, 'px');
                }
                
                const sectionSingle = document.querySelector('.section-single');
                if (sectionSingle) {
                    const sectionRect = sectionSingle.getBoundingClientRect();
                    console.log('\n📏 .section-single:');
                    console.log('  - width (CSS):', getComputedStyle(sectionSingle).width);
                    console.log('  - maxWidth (CSS):', getComputedStyle(sectionSingle).maxWidth);
                    console.log('  - getBoundingClientRect().width:', sectionRect.width, 'px');
                }
                
                if (boardContainer) {
                    const boardRect = boardContainer.getBoundingClientRect();
                    console.log('\n📏 .board-container (detalle):');
                    console.log('  - width (CSS):', getComputedStyle(boardContainer).width);
                    console.log('  - maxWidth (CSS):', getComputedStyle(boardContainer).maxWidth);
                    console.log('  - getBoundingClientRect().width:', boardRect.width, 'px');
                }
                
                console.log('\n🔎 [Vacante Debug] ============================================');
                console.log('🔎 [Vacante Debug] window.scrollY inicial:', window.scrollY);
                console.log('🔎 [Vacante Debug] ============================================\n');

                // Listener para detectar scroll en window
                let scrollCount = 0;
                window.addEventListener('scroll', () => {
                    scrollCount++;
                    if (scrollCount <= 5) { // Solo mostrar los primeros 5 eventos
                        console.warn('⚠️ [Vacante Debug] window.scrollY:', window.scrollY, '- ¡LA PÁGINA ESTÁ HACIENDO SCROLL!');
                    }
                }, { passive: true });

                // Listener para scroll en board-container
                if (boardContainer) {
                    boardContainer.addEventListener('scroll', () => {
                        console.log('📜 [Vacante Debug] board-container scrollTop:', boardContainer.scrollTop, '/ scrollHeight:', boardContainer.scrollHeight, '/ clientHeight:', boardContainer.clientHeight);
                    }, { passive: true });
                }
            } catch (e) {
                console.warn('⚠️ [Vacante Debug] Error al inicializar logs de depuración:', e);
            }
        });
        
        // Inicializar flujo vacío por defecto
        function initializeEmptyFlow() {
            console.log('🔧 [initializeEmptyFlow] Iniciando...');
            console.log('🔧 [initializeEmptyFlow] localTemplateCopy:', localTemplateCopy);
            
            // Solo inicializar si no hay una plantilla seleccionada
            if (!localTemplateCopy) {
                console.log('🔧 [initializeEmptyFlow] Creando flujo vacío...');
                localTemplateCopy = {
                    id: 'new-vacancy-flow',
                    name: 'Nuevo flujo de vacante',
                    category: 'reclutamiento',
                    status: 'draft',
                    createdAt: new Date().toISOString(),
                    lastModified: new Date().toISOString().split('T')[0],
                    author: 'Usuario',
                    avatar: 'images/Profile-image.jpg',
                    version: 1,
                    stages: 0,
                    agents: 0,
                    realContent: {
                        stages: []
                    }
                };
                
                // Asegurar que estamos en modo edición
                isEditMode = true;
                console.log('🔧 [initializeEmptyFlow] Modo edición activado');
                
                // Mostrar la sección de flujo
                const flowSection = document.getElementById('template-flow-section');
                const libraryWidget = document.getElementById('library-widget');
                
                console.log('🔧 [initializeEmptyFlow] flowSection:', flowSection);
                console.log('🔧 [initializeEmptyFlow] libraryWidget:', libraryWidget);
                
                if (flowSection) {
                    flowSection.style.display = 'flex';
                    flowSection.className = 'section-dual';
                    console.log('✅ [initializeEmptyFlow] Sección de flujo mostrada');
                } else {
                    console.error('❌ [initializeEmptyFlow] No se encontró template-flow-section');
                }
                
                if (libraryWidget) {
                    libraryWidget.style.display = 'flex';
                    console.log('✅ [initializeEmptyFlow] Biblioteca mostrada');
                } else {
                    console.error('❌ [initializeEmptyFlow] No se encontró library-widget');
                }
                
                // Renderizar el flujo vacío
                console.log('🔧 [initializeEmptyFlow] Renderizando flujo...');
                renderTemplateFlow(localTemplateCopy);
                
                // Aplicar modo edición
                console.log('🔧 [initializeEmptyFlow] Aplicando modo edición...');
                applyEditMode();
                
                // Renderizar contenido de la biblioteca
                setTimeout(() => {
                    console.log('🔧 [initializeEmptyFlow] Renderizando contenido de biblioteca...');
                    const activeTab = document.querySelector('#agents-sidebar .tab-button.active');
                    console.log('🔧 [initializeEmptyFlow] Tab activo:', activeTab);
                    if (activeTab && activeTab.dataset.tab === 'stages') {
                        console.log('🔧 [initializeEmptyFlow] Renderizando etapas...');
                        renderStages();
                    } else {
                        console.log('🔧 [initializeEmptyFlow] Renderizando agentes...');
                        renderAgents();
                    }
                }, 100);
            } else {
                console.log('ℹ️ [initializeEmptyFlow] Ya existe localTemplateCopy, no se inicializa flujo vacío');
            }
        }

        // Estado global
        let selectedTemplate = null;
        let localTemplateCopy = null; // Copia local para editar sin modificar la original
        let allTemplates = [];
        let isEditMode = true; // Modo edición activo por defecto

        // Agentes disponibles (mismo que en editor-plantillas.js)
        const AGENTS = [
            { 
                id: 'cv-analyzer', 
                name: 'Analizador CV', 
                icon: 'fa-file-alt',
                description: 'Analiza CV y asigna puntaje',
                hasConfig: true,
                config: {
                    salaryPercentage: { 
                        label: 'Margen sobre salario', 
                        type: 'number',
                        default: 25, 
                        suffix: '%',
                        tooltip: 'Define qué tanto puede superar el candidato el salario máximo del puesto y seguir siendo considerado.'
                    },
                    minScore: { 
                        label: 'Puntaje mínimo del CV', 
                        type: 'number',
                        default: 70, 
                        suffix: 'pts',
                        tooltip: 'Puntaje mínimo que el CV debe obtener para pasar a la siguiente etapa.'
                    },
                    acceptExEmployees: { 
                        label: 'Acepta ex colaboradores', 
                        type: 'radio',
                        default: 'si',
                        options: [
                            { value: 'si', text: 'Sí' },
                            { value: 'no', text: 'No' }
                        ]
                    }
                }
            },
            { 
                id: 'interview-ia', 
                name: 'Entrevista Serena', 
                icon: 'fa-comments',
                description: 'Genera preguntas y analiza respuestas',
                hasConfig: true,
                config: {
                    interviewType: {
                        label: 'Tipo de entrevista',
                        type: 'radio',
                        default: 'telefonica',
                        options: [
                            { value: 'telefonica', text: 'Telefónica' },
                            { value: 'virtual', text: 'Virtual' }
                        ]
                    },
                    voice: {
                        label: 'Voz de Serena',
                        type: 'select',
                        default: 'colombia',
                        options: [
                            { value: 'peru', text: 'Perú 🇵🇪' },
                            { value: 'costa-rica', text: 'Costa Rica 🇨🇷' },
                            { value: 'honduras', text: 'Honduras 🇭🇳' },
                            { value: 'argentina', text: 'Argentina 🇦🇷' },
                            { value: 'chile', text: 'Chile 🇨🇱' },
                            { value: 'mexico', text: 'México 🇲🇽' },
                            { value: 'colombia', text: 'Colombia 🇨🇴' }
                        ]
                    },
                    expirationDays: { 
                        label: 'Días para que expire la entrevista', 
                        type: 'number',
                        default: 0, 
                        suffix: 'días',
                        tooltip: 'Cantidad de días que el candidato tiene para completar la entrevista desde que recibe la invitación.'
                    },
                    minScore: { 
                        label: 'Puntaje mínimo de la entrevista', 
                        type: 'number',
                        default: 0, 
                        suffix: 'pts',
                        tooltip: 'Puntaje mínimo que el candidato debe obtener en la entrevista para avanzar a la siguiente etapa.'
                    }
                },
                voices: [
                    { id: 'peru', name: 'Perú', flag: '🇵🇪' },
                    { id: 'costa-rica', name: 'Costa Rica', flag: '🇨🇷' },
                    { id: 'honduras', name: 'Honduras', flag: '🇭🇳' },
                    { id: 'argentina', name: 'Argentina', flag: '🇦🇷' },
                    { id: 'chile', name: 'Chile', flag: '🇨🇱' },
                    { id: 'mexico', name: 'México', flag: '🇲🇽' },
                    { id: 'colombia', name: 'Colombia', flag: '🇨🇴' }
                ]
            },
            { 
                id: 'psychometric-analyst', 
                name: 'Analista psicométrico', 
                icon: 'fa-brain',
                description: 'Evalúa mediante pruebas psicométricas',
                hasConfig: true,
                config: {
                    minScore: { 
                        label: 'Puntaje mínimo global', 
                        type: 'number',
                        default: 0, 
                        suffix: 'pts' 
                    },
                    tests: {
                        label: 'Pruebas psicotécnicas',
                        type: 'psychometric-tests-manager',
                        default: []
                    }
                },
                testTypes: [
                    { value: 'cognicion', text: 'Cognición (inteligencia)' },
                    { value: 'perfil-motivacion', text: 'Perfil de motivación' },
                    { value: 'dominancia-cerebral', text: 'Dominancia Cerebral' },
                    { value: 'estilo-social', text: 'Estilo Social' },
                    { value: 'inventario-valores', text: 'Inventario de valores organizacionales (Corta)' },
                    { value: 'personalidad-16', text: 'Personalidad 16' }
                ],
                testLanguages: [
                    { value: 'es', text: 'Español' },
                    { value: 'en', text: 'Inglés' },
                    { value: 'pt', text: 'Portugués' }
                ]
            },
            { 
                id: 'background-check', 
                name: 'Antecedentes judiciales', 
                icon: 'fa-shield-alt',
                description: 'Verifica certificado de antecedentes judiciales',
                hasConfig: false
            }
        ];

        // Categorías fijas de etapas
        const STAGE_CATEGORIES = [
            { id: 'evaluacion-inicial', name: 'Evaluación inicial', icon: 'fa-clipboard-check' },
            { id: 'entrevistas', name: 'Entrevistas', icon: 'fa-comments' },
            { id: 'evaluacion-psicometrica', name: 'Evaluación psicométrica', icon: 'fa-brain' },
            { id: 'pruebas-tecnicas', name: 'Pruebas técnicas', icon: 'fa-code' },
            { id: 'verificacion', name: 'Verificación', icon: 'fa-shield-check' },
            { id: 'decision-final', name: 'Decisión final', icon: 'fa-gavel' }
        ];

        // Etapas creadas disponibles para arrastrar
        let availableStages = [];

        // Crear plantillas por defecto (misma función que en dashboard-plantillas.js)
        function createDefaultTemplates() {
            const now = new Date().toISOString();
            const today = now.split('T')[0];
            
            // Plantilla 1: Flujo estándar de selección con IA
            const template1 = {
                id: 'default-template-ia',
                name: 'Estándar de selección con IA',
                category: 'reclutamiento',
                status: 'available',
                createdAt: now,
                lastModified: today,
                author: 'Sistema',
                avatar: 'images/Profile-image.jpg',
                version: 2,
                stages: 8,
                agents: 4,
                isDefault: true,
                realContent: {
                    stages: [
                        {
                            id: 'stage-1',
                            type: 'custom',
                            name: 'Preguntas de filtro / formulario',
                            category: 'evaluacion-inicial',
                            description: 'Knockout questions simples: disponibilidad, ubicación, experiencia mínima, etc.',
                            templateId: 'default-pre-filter-requirements'
                        },
                        {
                            id: 'stage-2',
                            type: 'agent',
                            agentId: 'cv-analyzer',
                            name: 'Analizador de CV',
                            category: 'evaluacion-inicial',
                            config: {
                                salaryPercentage: 25,
                                minScore: 70,
                                acceptExEmployees: 'si'
                            }
                        },
                        {
                            id: 'stage-3',
                            type: 'custom',
                            name: 'Entrevista con reclutador',
                            category: 'entrevistas',
                            description: 'Entrevista más profunda para evaluar competencias blandas, expectativas y encaje general con la empresa.',
                            templateId: 'default-interview-recruiter'
                        },
                        {
                            id: 'stage-4',
                            type: 'agent',
                            agentId: 'interview-ia',
                            name: 'Entrevista Serena',
                            category: 'entrevistas',
                            config: {
                                interviewType: 'telefonica',
                                voice: 'colombia',
                                expirationDays: 0,
                                minScore: 0
                            }
                        },
                        {
                            id: 'stage-5',
                            type: 'agent',
                            agentId: 'psychometric-analyst',
                            name: 'Analista psicométrico',
                            category: 'evaluacion-psicometrica',
                            config: {
                                minScore: 0,
                                tests: []
                            }
                        },
                        {
                            id: 'stage-6',
                            type: 'custom',
                            name: 'Entrevista con el hiring manager',
                            category: 'entrevistas',
                            description: 'Entrevista técnica o funcional con el responsable del área para evaluar ajuste al rol.',
                            templateId: 'default-interview-hiring-manager'
                        },
                        {
                            id: 'stage-7',
                            type: 'agent',
                            agentId: 'background-check',
                            name: 'Verificación de antecedentes judiciales',
                            category: 'verificacion'
                        },
                        {
                            id: 'stage-8',
                            type: 'custom',
                            name: 'Cierre del proceso',
                            category: 'decision-final',
                            description: 'Última etapa para registrar la decisión final sobre el candidato: aprobado, no aprobado o en espera.',
                            templateId: 'default-final-review'
                        }
                    ]
                }
            };
            
            // Plantilla 2: Flujo estándar de selección (sin IA)
            const template2 = {
                id: 'default-template-standard',
                name: 'Estándar de selección',
                category: 'reclutamiento',
                status: 'available',
                createdAt: now,
                lastModified: today,
                author: 'Sistema',
                avatar: 'images/Profile-image.jpg',
                version: 2,
                stages: 7,
                agents: 0,
                isDefault: true,
                realContent: {
                    stages: [
                        {
                            id: 'stage-1',
                            type: 'custom',
                            name: 'Preguntas de filtro / formulario inicial',
                            category: 'evaluacion-inicial',
                            description: 'Cuestionario con preguntas knockout: disponibilidad, ubicación, experiencia mínima, etc.',
                            templateId: 'default-pre-filter-requirements'
                        },
                        {
                            id: 'stage-2',
                            type: 'custom',
                            name: 'Revisión de CV',
                            category: 'evaluacion-inicial',
                            description: 'Revisión inicial del currículum para validar requisitos clave y rango salarial esperado.',
                            templateId: 'default-review-cv'
                        },
                        {
                            id: 'stage-3',
                            type: 'custom',
                            name: 'Entrevista con el reclutador',
                            category: 'entrevistas',
                            description: 'Entrevista más profunda para validar encaje con la empresa y el proceso.',
                            templateId: 'default-interview-recruiter'
                        },
                        {
                            id: 'stage-4',
                            type: 'custom',
                            name: 'Evaluación psicométrica',
                            category: 'evaluacion-psicometrica',
                            description: 'Aplicación y revisión de pruebas psicométricas según el tipo de rol.',
                            templateId: 'default-psychometric-general'
                        },
                        {
                            id: 'stage-5',
                            type: 'custom',
                            name: 'Entrevista con el hiring manager / área',
                            category: 'entrevistas',
                            description: 'Entrevista técnica o funcional para evaluar el ajuste al rol específico.',
                            templateId: 'default-interview-hiring-manager'
                        },
                        {
                            id: 'stage-6',
                            type: 'custom',
                            name: 'Verificación de antecedentes judiciales',
                            category: 'verificacion',
                            description: 'Revisión de antecedentes del candidato según la normativa vigente y las políticas internas.',
                            templateId: 'default-verify-background'
                        },
                        {
                            id: 'stage-7',
                            type: 'custom',
                            name: 'Cierre del proceso',
                            category: 'decision-final',
                            description: 'Registro de la decisión final sobre el candidato: aprobado, no aprobado o en espera.',
                            templateId: 'default-final-review'
                        }
                    ]
                }
            };
            
            return [template1, template2];
        }

        // Cargar plantillas desde localStorage
        function loadTemplates() {
            const stored = localStorage.getItem('templates');
            if (stored) {
                allTemplates = JSON.parse(stored);
                console.log('📋 [loadTemplates] Plantillas cargadas:', allTemplates.length);
                console.log('📋 [loadTemplates] Plantillas:', allTemplates.map(t => ({ id: t.id, name: t.name, isDefault: t.isDefault })));
                
                // Actualizar nombres de plantillas por defecto si tienen nombres antiguos
                let needsUpdate = false;
                allTemplates.forEach(template => {
                    if (template.isDefault) {
                        if (template.id === 'default-template-ia' && (template.name === 'Plantilla por defecto – Flujo estándar de selección con IA' || template.name === 'Plantilla estándar de selección con IA')) {
                            template.name = 'Estándar de selección con IA';
                            needsUpdate = true;
                        } else if (template.id === 'default-template-standard' && (template.name === 'Plantilla por defecto – Flujo estándar de selección' || template.name === 'Plantilla flujo estándar de selección' || template.name === 'Flujo estándar de selección')) {
                            template.name = 'Estándar de selección';
                            needsUpdate = true;
                        }
                    }
                });
                
                if (needsUpdate) {
                    localStorage.setItem('templates', JSON.stringify(allTemplates));
                    console.log('📋 [loadTemplates] Nombres de plantillas por defecto actualizados');
                }
                
                // Verificar si ya existen las plantillas por defecto
                const hasDefaultTemplates = allTemplates.some(t => t.isDefault === true);
                console.log('📋 [loadTemplates] ¿Tiene plantillas por defecto?', hasDefaultTemplates);
                
                // Actualizar plantillas por defecto existentes
                const defaultTemplateIA = allTemplates.find(t => t.id === 'default-template-ia');
                const defaultTemplateStandard = allTemplates.find(t => t.id === 'default-template-standard');
                
                if (defaultTemplateIA || defaultTemplateStandard) {
                    const defaultTemplates = createDefaultTemplates();
                    
                    // Actualizar plantilla IA
                    if (defaultTemplateIA && defaultTemplateIA.realContent) {
                        const newIATemplate = defaultTemplates.find(t => t.id === 'default-template-ia');
                        if (newIATemplate) {
                            const currentStagesCount = defaultTemplateIA.realContent.stages?.length || 0;
                            const newStagesCount = newIATemplate.realContent.stages?.length || 0;
                            
                            if (currentStagesCount !== newStagesCount || defaultTemplateIA.version < newIATemplate.version) {
                                console.log('🔄 [loadTemplates] Actualizando estructura de plantilla IA...');
                                defaultTemplateIA.realContent = JSON.parse(JSON.stringify(newIATemplate.realContent));
                                defaultTemplateIA.stages = newIATemplate.stages;
                                defaultTemplateIA.agents = newIATemplate.agents;
                                defaultTemplateIA.version = newIATemplate.version;
                                defaultTemplateIA.lastModified = newIATemplate.lastModified;
                                needsUpdate = true;
                            }
                        }
                    }
                    
                    // Actualizar plantilla Standard
                    if (defaultTemplateStandard && defaultTemplateStandard.realContent) {
                        const newStandardTemplate = defaultTemplates.find(t => t.id === 'default-template-standard');
                        if (newStandardTemplate) {
                            const currentStagesCount = defaultTemplateStandard.realContent.stages?.length || 0;
                            const newStagesCount = newStandardTemplate.realContent.stages?.length || 0;
                            
                            if (currentStagesCount !== newStagesCount || defaultTemplateStandard.version < newStandardTemplate.version) {
                                console.log('🔄 [loadTemplates] Actualizando estructura de plantilla Standard...');
                                defaultTemplateStandard.realContent = JSON.parse(JSON.stringify(newStandardTemplate.realContent));
                                defaultTemplateStandard.stages = newStandardTemplate.stages;
                                defaultTemplateStandard.agents = newStandardTemplate.agents;
                                defaultTemplateStandard.version = newStandardTemplate.version;
                                defaultTemplateStandard.lastModified = newStandardTemplate.lastModified;
                                needsUpdate = true;
                            }
                        }
                    }
                    
                    if (needsUpdate) {
                        localStorage.setItem('templates', JSON.stringify(allTemplates));
                        console.log('📋 [loadTemplates] Plantillas por defecto actualizadas');
                    }
                }
                
                if (!hasDefaultTemplates) {
                    console.log('📋 [loadTemplates] Creando plantillas por defecto...');
                    // Agregar plantillas por defecto si no existen
                    const defaultTemplates = createDefaultTemplates();
                    console.log('📋 [loadTemplates] Plantillas por defecto creadas:', defaultTemplates.length);
                    allTemplates = [...defaultTemplates, ...allTemplates];
                    localStorage.setItem('templates', JSON.stringify(allTemplates));
                    console.log('📋 [loadTemplates] Plantillas guardadas. Total:', allTemplates.length);
                }
            } else {
                console.log('📋 [loadTemplates] No hay plantillas guardadas. Creando plantillas por defecto...');
                // Crear plantillas por defecto
                allTemplates = createDefaultTemplates();
                console.log('📋 [loadTemplates] Plantillas por defecto creadas:', allTemplates.length);
                localStorage.setItem('templates', JSON.stringify(allTemplates));
                console.log('📋 [loadTemplates] Plantillas guardadas.');
            }
            console.log('📋 [loadTemplates] Retornando plantillas:', allTemplates.map(t => t.name));
            return allTemplates;
        }

        // Variable global para mantener referencia al input del selector
        let globalTemplateInput = null;

        // Crear selector de plantilla con UBITS Input
        function createTemplateSelect(initialValue = 'custom') {
            const allTemplates = loadTemplates();
            
            // Filtrar solo plantillas disponibles (status === 'available')
            const availableTemplates = allTemplates.filter(template => template.status === 'available');
            
            // Crear opciones para el selector
            // Primero agregar la opción "Personalizada"
            const selectOptions = [
                {
                    value: 'custom',
                    text: 'Personalizada'
                },
                // Luego agregar las plantillas disponibles
                ...availableTemplates.map(template => ({
                    value: template.id,
                    text: template.name
                }))
            ];
            
            // Limpiar el contenedor antes de crear el nuevo input
            const container = document.getElementById('template-input-container');
            if (container) {
                container.innerHTML = '';
            }

            globalTemplateInput = createInput({
                containerId: 'template-input-container',
                type: 'select',
                placeholder: 'Selecciona una plantilla...',
                selectOptions: selectOptions,
                value: initialValue, // Usar el valor inicial proporcionado
                onChange: function(value) {
                    if (value) {
                        selectTemplate(value);
                    } else {
                        hideTemplateFlow();
                    }
                }
            });
            
            // Establecer el valor inicial
            setTimeout(() => {
                // Usar setValue del componente para establecer el valor correctamente
                if (globalTemplateInput && typeof globalTemplateInput.setValue === 'function') {
                    globalTemplateInput.setValue(initialValue);
                }
                // Inicializar el flujo según el valor inicial
                if (initialValue === 'custom') {
                    selectTemplate('custom');
                } else {
                    selectTemplate(initialValue);
                }
            }, 300);
        }

        // Seleccionar plantilla y mostrar su flujo
        function selectTemplate(templateId) {
            // Si se selecciona "Personalizada", crear un flujo vacío
            if (templateId === 'custom') {
                selectedTemplate = null;
                localTemplateCopy = {
                    id: 'new-vacancy-flow',
                    name: 'Nuevo flujo de vacante',
                    category: 'reclutamiento',
                    status: 'draft',
                    createdAt: new Date().toISOString(),
                    lastModified: new Date().toISOString().split('T')[0],
                    author: 'Usuario',
                    avatar: 'images/Profile-image.jpg',
                    version: 1,
                    stages: 0,
                    agents: 0,
                    realContent: {
                        stages: []
                    }
                };
                
                // Asegurar que estamos en modo edición
                isEditMode = true;
                
                // Mostrar la sección de flujo
                const flowSection = document.getElementById('template-flow-section');
                const libraryWidget = document.getElementById('library-widget');
                
                if (flowSection) {
                    flowSection.style.display = 'flex';
                    flowSection.className = 'section-dual';
                }
                
                if (libraryWidget) {
                    libraryWidget.style.display = 'flex';
                }
                
                // Renderizar el flujo vacío
                renderTemplateFlow(localTemplateCopy);
                
                // Aplicar modo edición
                applyEditMode();
                
                // Renderizar contenido de la biblioteca
                setTimeout(() => {
                    const activeTab = document.querySelector('#agents-sidebar .tab-button.active');
                    if (activeTab && activeTab.dataset.tab === 'stages') {
                        renderStages();
                    } else {
                        renderAgents();
                    }
                }, 100);
                
                return;
            }
            
            const template = allTemplates.find(t => t.id === templateId);
            if (!template) {
                console.error('Plantilla no encontrada:', templateId);
                return;
            }

            selectedTemplate = template;
            // Crear copia local profunda para editar sin modificar la original
            localTemplateCopy = JSON.parse(JSON.stringify(template));
            
            // Inicializar configuraciones faltantes para agentes existentes
            if (localTemplateCopy.realContent && localTemplateCopy.realContent.stages) {
                localTemplateCopy.realContent.stages.forEach(stage => {
                    if (stage.type === 'agent' && stage.agentId) {
                        const agentData = AGENTS.find(a => a.id === stage.agentId);
                        if (agentData && agentData.config) {
                            // Asegurar que stage.config existe
                            if (!stage.config) {
                                stage.config = {};
                            }
                            // Inicializar valores por defecto si faltan
                            Object.entries(agentData.config).forEach(([key, field]) => {
                                if (stage.config[key] === undefined || stage.config[key] === null) {
                                    stage.config[key] = field.default;
                                }
                            });
                            // Inicializar tests para psicométrico si no existe
                            if (stage.agentId === 'psychometric-analyst' && !stage.config.tests) {
                                stage.config.tests = [];
                            }
                        }
                    }
                });
            }
            
            // Cargar en modo vista (no edición)
            isEditMode = false;
            const libraryWidget = document.getElementById('library-widget');
            const flowSection = document.getElementById('template-flow-section');
            if (libraryWidget) {
                libraryWidget.style.display = 'none'; // Ocultar biblioteca en modo vista
            }
            if (flowSection) {
                flowSection.className = 'section-single'; // Solo mostrar el flujo en modo vista
                flowSection.style.display = 'flex';
            }
            
            renderTemplateFlow(localTemplateCopy);
            // Aplicar modo vista después de renderizar
            applyEditMode();
        }
        
        // Inicializar flujo vacío por defecto
        function initializeEmptyFlow() {
            localTemplateCopy = {
                id: 'new-vacancy-flow',
                name: 'Nuevo flujo de vacante',
                category: 'reclutamiento',
                status: 'draft',
                createdAt: new Date().toISOString(),
                lastModified: new Date().toISOString().split('T')[0],
                author: 'Usuario',
                avatar: 'images/Profile-image.jpg',
                version: 1,
                stages: 0,
                agents: 0,
                realContent: {
                    stages: []
                }
            };
            
            // Mostrar la sección de flujo
            const flowSection = document.getElementById('template-flow-section');
            const libraryWidget = document.getElementById('library-widget');
            
            if (flowSection) {
                flowSection.style.display = 'flex';
                flowSection.className = 'section-dual';
            }
            
            if (libraryWidget) {
                libraryWidget.style.display = 'flex';
            }
            
            // Renderizar el flujo vacío
            renderTemplateFlow(localTemplateCopy);
            
            // Renderizar contenido de la biblioteca
            setTimeout(() => {
                const activeTab = document.querySelector('#agents-sidebar .tab-button.active');
                if (activeTab && activeTab.dataset.tab === 'stages') {
                    renderStages();
                } else {
                    renderAgents();
                }
            }, 100);
        }

        // Actualizar stepper según si hay Serena IA en el flujo
        function updateStepper() {
            console.log('🔧 [updateStepper] Iniciando actualización del stepper...');
            
            if (!localTemplateCopy || !localTemplateCopy.realContent || !localTemplateCopy.realContent.stages) {
                console.log('🔧 [updateStepper] No hay flujo, ocultando paso 3');
                // Si no hay flujo, ocultar paso 3
                const step3 = document.getElementById('stepper-step-3');
                if (step3) {
                    step3.style.display = 'none';
                    console.log('✅ [updateStepper] Paso 3 ocultado');
                }
                // Renumerar pasos
                renumberStepperSteps();
                // Actualizar mobile stepper: 2/4 (sin paso 3)
                updateMobileStepper(4);
                return;
            }

            // Verificar si hay un agente con agentId === 'interview-ia'
            const hasSerenaIA = localTemplateCopy.realContent.stages.some(
                stage => stage.type === 'agent' && stage.agentId === 'interview-ia'
            );

            console.log('🔧 [updateStepper] ¿Hay Serena IA?', hasSerenaIA);
            console.log('🔧 [updateStepper] Etapas:', localTemplateCopy.realContent.stages.map(s => ({
                type: s.type,
                agentId: s.agentId,
                name: s.name
            })));

            const step3 = document.getElementById('stepper-step-3');
            if (step3) {
                if (hasSerenaIA) {
                    step3.style.display = 'flex';
                    console.log('✅ [updateStepper] Paso 3 mostrado (hay Serena IA)');
                } else {
                    step3.style.display = 'none';
                    console.log('✅ [updateStepper] Paso 3 ocultado (no hay Serena IA)');
                }
            } else {
                console.log('❌ [updateStepper] No se encontró el paso 3');
            }

            // Renumerar pasos
            renumberStepperSteps();
            
            // Actualizar mobile stepper: 2/5 si hay paso 3, 2/4 si no
            updateMobileStepper(hasSerenaIA ? 5 : 4);
        }

        // Actualizar mobile stepper con el total de pasos
        function updateMobileStepper(totalSteps) {
            const mobileProgressCircle = document.querySelector('.mobile-progress-circle');
            if (!mobileProgressCircle) return;

            // Actualizar el texto "2/5" o "2/4"
            const span = mobileProgressCircle.querySelector('span');
            if (span) {
                span.textContent = `2/${totalSteps}`;
            }

            // Actualizar el atributo data-progress para el cálculo del círculo
            // 2 de 5 = 40%, 2 de 4 = 50%
            const progress = totalSteps === 5 ? 40 : 50;
            mobileProgressCircle.setAttribute('data-progress', progress);

            // Actualizar el stroke-dashoffset del círculo de progreso
            const progressFill = mobileProgressCircle.querySelector('.mobile-progress-fill');
            if (progressFill) {
                const circumference = 2 * Math.PI * 22; // radio = 22
                const offset = circumference * (1 - progress / 100);
                progressFill.style.strokeDashoffset = offset;
            }
        }

        // Renumerar los pasos del stepper cuando el paso 3 está oculto
        function renumberStepperSteps() {
            const step3 = document.getElementById('stepper-step-3');
            
            // Verificar si el paso 3 está visible usando getComputedStyle
            let isStep3Visible = false;
            if (step3) {
                const computedStyle = window.getComputedStyle(step3);
                isStep3Visible = computedStyle.display !== 'none';
                console.log('🔧 [renumberStepperSteps] Paso 3 visible?', isStep3Visible, 'display:', computedStyle.display);
            }

            // Obtener todos los pasos del stepper
            const stepper = document.querySelector('.stepper');
            if (!stepper) {
                console.log('❌ [renumberStepperSteps] No se encontró el stepper');
                return;
            }

            const steps = Array.from(stepper.querySelectorAll('.stepper-item'));
            console.log('🔧 [renumberStepperSteps] Total de pasos encontrados:', steps.length);
            
            // Renumerar basándonos en el índice original del paso
            steps.forEach((step, index) => {
                const circle = step.querySelector('.stepper-circle');
                if (!circle) return;

                // Si tiene icono, no renumerar (es el paso 1 o el último paso)
                if (circle.querySelector('.stepper-icon')) {
                    console.log(`🔧 [renumberStepperSteps] Paso ${index}: tiene icono, no se renumerar`);
                    return;
                }

                // Estructura del stepper:
                // Índice 0: Paso 1 (Información básica) - tiene icono check, no se renumerar
                // Índice 1: Paso 2 (Flujo del candidato) - siempre es 2
                // Índice 2: Paso 3 (Preguntas Serena IA) - puede estar oculto
                // Índice 3: Paso 4 (Añade miembros) - debe ser 3 si paso 3 está oculto, 4 si está visible
                // Índice 4: Paso 5 (Publícala) - tiene icono paper-plane, no se renumerar

                if (index === 1) {
                    // Paso 2: siempre es 2
                    circle.textContent = '2';
                    console.log(`✅ [renumberStepperSteps] Paso ${index} (Paso 2): renumerado a 2`);
                } else if (index === 2) {
                    // Paso 3: solo actualizar si está visible
                    if (isStep3Visible) {
                        circle.textContent = '3';
                        console.log(`✅ [renumberStepperSteps] Paso ${index} (Paso 3): renumerado a 3`);
                    } else {
                        console.log(`⏭️ [renumberStepperSteps] Paso ${index} (Paso 3): oculto, no se renumerar`);
                    }
                } else if (index === 3) {
                    // Paso 4: si el paso 3 está oculto, se convierte en paso 3
                    if (!isStep3Visible) {
                        circle.textContent = '3';
                        console.log(`✅ [renumberStepperSteps] Paso ${index} (Paso 4): renumerado a 3 (porque paso 3 está oculto)`);
                    } else {
                        circle.textContent = '4';
                        console.log(`✅ [renumberStepperSteps] Paso ${index} (Paso 4): renumerado a 4 (porque paso 3 está visible)`);
                    }
                }
            });
        }

        // Renderizar el flujo de la plantilla (igual que en el editor)
        function renderTemplateFlow(template) {
            const flowSection = document.getElementById('template-flow-section');
            const flowContainer = document.getElementById('template-flow-container');

            if (!flowSection || !flowContainer) return;

            // Mostrar la sección
            flowSection.style.display = 'flex';

            // Verificar si tiene etapas
            if (!template.realContent || !template.realContent.stages || template.realContent.stages.length === 0) {
                // Header con título y botones (solo si hay plantilla seleccionada)
                const headerHTML = selectedTemplate ? `
                    <div class="board-header-section">
                        <div class="board-header-top">
                            <div class="board-header-title-wrapper">
                                <h3 class="board-header-title">Flujo del candidato</h3>
                                ${isEditMode ? '<p class="board-header-description">Arrastra aquí las etapas y etapas con IA en el orden en que el candidato las irá completando.</p>' : ''}
                            </div>
                            <div class="board-header-actions">
                                <button class="ubits-button ubits-button--secondary ubits-button--sm" onclick="goToTemplate()">
                                    <i class="far fa-external-link"></i>
                                    <span>Ir a la plantilla</span>
                                </button>
                                <button class="ubits-button ubits-button--primary ubits-button--sm" id="editFlowBtn" onclick="toggleEditMode()">
                                    <i class="far fa-edit"></i>
                                    <span>Editar flujo</span>
                                </button>
                            </div>
                        </div>
                    </div>
                ` : (isEditMode ? `
                    <div class="board-header-section">
                        <div class="board-header-top">
                            <div class="board-header-title-wrapper">
                                <h3 class="board-header-title">Flujo del candidato</h3>
                                <p class="board-header-description">Arrastra aquí las etapas y etapas con IA en el orden en que el candidato las irá completando.</p>
                            </div>
                            <div class="board-header-actions">
                                <button class="ubits-button ubits-button--secondary ubits-button--sm" onclick="saveAsTemplate()" id="saveTemplateBtn">
                                    <i class="far fa-save"></i>
                                    <span>Guardar plantilla</span>
                                </button>
                            </div>
                        </div>
                    </div>
                ` : '');
                
                flowContainer.innerHTML = headerHTML + `
                    <div class="board-drop-slots ${isEditMode ? 'editing-mode' : ''}">
                        <div class="board-drop-slot" data-slot-number="1">
                            <div class="slot-number">1</div>
                            <div class="slot-placeholder">Arrastra una etapa o agente IA desde la izquierda</div>
                        </div>
                    </div>
                `;
                
                // Aplicar modo edición después de renderizar
                setTimeout(() => {
                    applyEditMode();
                    makeBoardDroppable(); // Configurar drag and drop
                }, 100);
                
                return;
            }

            // Crear HTML de las etapas (igual que en el editor)
            const stagesHTML = template.realContent.stages.map((stage, index) => {
                if (stage.type === 'agent' && stage.agentId) {
                    return renderAgentStageCard(stage, index, template);
                } else {
                    return renderCustomStageCard(stage, index, template);
                }
            }).join('');

            // Calcular el número del siguiente slot
            const nextSlotNumber = template.realContent.stages.length + 1;

            // Crear el slot adicional para la siguiente etapa (solo visible en modo edición)
            const nextSlotHTML = `
                <div class="board-drop-slots ${isEditMode ? 'editing-mode' : ''}">
                    <div class="board-drop-slot" data-slot-number="${nextSlotNumber}">
                        <div class="slot-number">${nextSlotNumber}</div>
                        <div class="slot-placeholder">Arrastra una etapa o agente IA desde la izquierda</div>
                    </div>
                </div>
            `;

            // Header con botones según el modo
            let headerActionsHTML = '';
            if (selectedTemplate) {
                // Si hay plantilla seleccionada, mostrar botones de ir a plantilla y editar
                headerActionsHTML = `
                    <div class="flow-header-actions">
                        <button class="ubits-button ubits-button--secondary ubits-button--sm" onclick="goToTemplate()" id="goToTemplateBtn">
                            <i class="far fa-external-link"></i>
                            <span>Ir a la plantilla</span>
                        </button>
                        <button class="ubits-button ubits-button--primary ubits-button--sm" onclick="toggleEditMode()" id="editFlowBtn">
                            <i class="far fa-edit"></i>
                            <span>Editar flujo</span>
                        </button>
                    </div>
                `;
            } else if (!selectedTemplate && localTemplateCopy) {
                // Si es modo personalizada, mostrar botón de guardar plantilla
                headerActionsHTML = `
                    <div class="flow-header-actions">
                        <button class="ubits-button ubits-button--secondary ubits-button--sm" onclick="saveAsTemplate()" id="saveTemplateBtn">
                            <i class="far fa-save"></i>
                            <span>Guardar plantilla</span>
                        </button>
                    </div>
                `;
            }
            
            // Mostrar las etapas con el slot adicional (igual que en el editor)
            flowContainer.innerHTML = `
                <div class="board-header-section">
                    <div class="board-header-top">
                        <div class="board-header-title-wrapper">
                            <h3 class="board-header-title">Flujo del candidato</h3>
                            ${isEditMode ? '<p class="board-header-description">Arrastra aquí las etapas y agentes de IA en el orden en que el candidato las irá completando.</p>' : ''}
                        </div>
                        ${headerActionsHTML}
                    </div>
                </div>
                ${stagesHTML}
                ${nextSlotHTML}
                <div class="board-scroll-spacer"></div>
            `;

            // Aplicar modo vista/edición según el estado
            applyEditMode();

            // Logs para debuggear el scroll
            setTimeout(() => {
                const boardContainer = document.querySelector('.board-container');
                if (boardContainer) {
                    console.log('🔍 [Scroll Debug] ============================================');
                    console.log('🔍 [Scroll Debug] BOARD CONTAINER SCROLL INFO');
                    console.log('🔍 [Scroll Debug] ============================================');
                    console.log('📦 boardContainer.scrollHeight:', boardContainer.scrollHeight, 'px');
                    console.log('📦 boardContainer.clientHeight:', boardContainer.clientHeight, 'px');
                    console.log('📦 boardContainer.scrollTop:', boardContainer.scrollTop, 'px');
                    console.log('📦 boardContainer.maxHeight (computed):', window.getComputedStyle(boardContainer).maxHeight);
                    console.log('📦 boardContainer.maxHeight (calc):', 'calc(100vh - 240px)');
                    console.log('📦 window.innerHeight:', window.innerHeight, 'px');
                    console.log('📦 Calculated max-height:', window.innerHeight - 240, 'px');
                    console.log('📦 Diferencia (scrollHeight - clientHeight):', boardContainer.scrollHeight - boardContainer.clientHeight, 'px');
                    console.log('📦 ¿Tiene scroll?', boardContainer.scrollHeight > boardContainer.clientHeight ? '✅ SÍ' : '❌ NO');
                    
                    // Verificar el último elemento
                    const lastStage = boardContainer.querySelector('.stage-item:last-child');
                    const spacer = boardContainer.querySelector('.board-scroll-spacer');
                    if (lastStage) {
                        const lastStageRect = lastStage.getBoundingClientRect();
                        const containerRect = boardContainer.getBoundingClientRect();
                        console.log('📦 Último stage-item:');
                        console.log('   - bottom:', lastStageRect.bottom, 'px');
                        console.log('   - container bottom:', containerRect.bottom, 'px');
                        console.log('   - Diferencia:', containerRect.bottom - lastStageRect.bottom, 'px');
                        console.log('   - ¿Está visible?', lastStageRect.bottom <= containerRect.bottom ? '✅ SÍ' : '❌ NO (cortado)');
                    }
                    if (spacer) {
                        const spacerRect = spacer.getBoundingClientRect();
                        const containerRect = boardContainer.getBoundingClientRect();
                        console.log('📦 Spacer:');
                        console.log('   - bottom:', spacerRect.bottom, 'px');
                        console.log('   - container bottom:', containerRect.bottom, 'px');
                        console.log('   - Diferencia:', containerRect.bottom - spacerRect.bottom, 'px');
                    }
                    
                    // Verificar todos los elementos
                    const allStages = boardContainer.querySelectorAll('.stage-item');
                    console.log('📦 Total de stage-items:', allStages.length);
                    allStages.forEach((stage, index) => {
                        const rect = stage.getBoundingClientRect();
                        const containerRect = boardContainer.getBoundingClientRect();
                        const isVisible = rect.bottom <= containerRect.bottom && rect.top >= containerRect.top;
                        console.log(`   Stage ${index + 1}:`, {
                            top: rect.top.toFixed(0) + 'px',
                            bottom: rect.bottom.toFixed(0) + 'px',
                            visible: isVisible ? '✅' : '❌'
                        });
                    });
                    
                    console.log('✅ [Scroll Debug] ============================================');
                }
            }, 300);

            // Configurar drag and drop después de renderizar
            setTimeout(() => {
                makeBoardDroppable();
                
                // Configurar drag and drop para reordenar etapas en el board
                const boardContainer = document.querySelector('.board-container');
                if (boardContainer) {
                    boardContainer.querySelectorAll('.stage-item').forEach(item => {
                        // Remover listeners previos si existen para evitar duplicados
                        item.removeEventListener('dragstart', handleBoardStageDragStart);
                        item.removeEventListener('dragover', handleBoardStageDragOver);
                        item.removeEventListener('drop', handleBoardStageDrop);
                        item.removeEventListener('dragend', handleBoardStageDragEnd);
                        item.removeEventListener('dragleave', handleBoardStageDragLeave);
                        
                        // Agregar nuevos listeners
                        item.addEventListener('dragstart', handleBoardStageDragStart);
                        item.addEventListener('dragover', handleBoardStageDragOver);
                        item.addEventListener('drop', handleBoardStageDrop);
                        item.addEventListener('dragend', handleBoardStageDragEnd);
                        item.addEventListener('dragleave', handleBoardStageDragLeave);
                    });
                }
            }, 100);

            // Crear inputs UBITS para campos select después de renderizar (solo en modo edición)
            if (isEditMode) {
                setTimeout(() => {
                    createConfigInputs(template);
                    
                    // Agregar event listeners para tooltips de campos de configuración
                    const boardContainer = document.querySelector('.board-container');
                    if (boardContainer) {
                        boardContainer.querySelectorAll('.config-info-btn').forEach(btn => {
                            // Remover listeners previos si existen para evitar duplicados
                            btn.removeEventListener('mouseenter', handleConfigInfoHover);
                            btn.removeEventListener('mouseleave', handleConfigInfoLeave);
                            // Agregar nuevos listeners
                            btn.addEventListener('mouseenter', handleConfigInfoHover);
                            btn.addEventListener('mouseleave', handleConfigInfoLeave);
                        });
                        
                        // Agregar event listeners para tooltips de información de agentes en las cards del flujo
                        boardContainer.querySelectorAll('.agent-info-btn').forEach(btn => {
                            // Remover listeners previos si existen para evitar duplicados
                            btn.removeEventListener('mouseenter', handleAgentInfoHover);
                            btn.removeEventListener('mouseleave', handleAgentInfoLeave);
                            // Agregar nuevos listeners
                            btn.addEventListener('mouseenter', handleAgentInfoHover);
                            btn.addEventListener('mouseleave', handleAgentInfoLeave);
                        });
                    }
                }, 100);
            } else {
                // En modo vista, también agregar event listeners para tooltips de información de agentes
                setTimeout(() => {
                    const boardContainer = document.querySelector('.board-container');
                    if (boardContainer) {
                        boardContainer.querySelectorAll('.agent-info-btn').forEach(btn => {
                            // Remover listeners previos si existen para evitar duplicados
                            btn.removeEventListener('mouseenter', handleAgentInfoHover);
                            btn.removeEventListener('mouseleave', handleAgentInfoLeave);
                            // Agregar nuevos listeners
                            btn.addEventListener('mouseenter', handleAgentInfoHover);
                            btn.addEventListener('mouseleave', handleAgentInfoLeave);
                        });
                    }
                }, 100);
            }

            // Actualizar stepper según si hay Serena IA
            updateStepper();
        }

        // Aplicar modo edición/vista
        function applyEditMode() {
            const stageActions = document.querySelectorAll('.stage-actions');
            const stageDragHandles = document.querySelectorAll('.stage-drag-handle');
            const editFlowBtn = document.getElementById('editFlowBtn');
            const dropSlots = document.querySelector('.board-drop-slots');
            const boardContainer = document.querySelector('.board-container');
            const widgetTemplateFlow = document.querySelector('.widget-template-flow');
            
            if (isEditMode) {
                // Modo edición: mostrar botones y iconos de arrastrar
                stageActions.forEach(actions => {
                    actions.classList.add('editing-mode');
                });
                stageDragHandles.forEach(handle => {
                    handle.classList.add('editing-mode');
                });
                if (dropSlots) {
                    dropSlots.classList.add('editing-mode');
                }
                if (editFlowBtn) {
                    editFlowBtn.innerHTML = '<i class="far fa-eye"></i><span>Ver flujo</span>';
                }
                // Agregar clase de edición para mostrar fondo de las cards
                if (boardContainer) {
                    boardContainer.classList.add('editing-mode');
                    boardContainer.classList.remove('view-mode');
                }
            } else {
                // Modo vista: ocultar botones y iconos de arrastrar
                stageActions.forEach(actions => {
                    actions.classList.remove('editing-mode');
                });
                stageDragHandles.forEach(handle => {
                    handle.classList.remove('editing-mode');
                });
                if (dropSlots) {
                    dropSlots.classList.remove('editing-mode');
                }
                if (editFlowBtn) {
                    editFlowBtn.innerHTML = '<i class="far fa-edit"></i><span>Editar flujo</span>';
                }
                // Agregar clase de vista para quitar fondo de las cards
                if (boardContainer) {
                    boardContainer.classList.remove('editing-mode');
                    boardContainer.classList.add('view-mode');
                }
            }
        }

        // Toggle modo edición
        window.toggleEditMode = function() {
            isEditMode = !isEditMode;
            
            // Mostrar/ocultar biblioteca
            const libraryWidget = document.getElementById('library-widget');
            if (libraryWidget) {
                if (isEditMode) {
                    libraryWidget.style.display = 'flex';
                    // Renderizar contenido según el tab activo cuando se muestra
                    setTimeout(() => {
                        const activeTab = document.querySelector('#agents-sidebar .tab-button.active');
                        if (activeTab && activeTab.dataset.tab === 'stages') {
                            renderStages();
                        } else {
                            renderAgents();
                        }
                    }, 100);
                } else {
                    libraryWidget.style.display = 'none';
                }
            }
            
            // Cambiar de section-single a section-dual cuando se activa edición
            const flowSection = document.getElementById('template-flow-section');
            if (flowSection) {
                if (isEditMode) {
                    flowSection.className = 'section-dual';
                } else {
                    flowSection.className = 'section-single';
                }
            }
            
            // Re-renderizar para mostrar/ocultar botones de edición
            if (localTemplateCopy) {
                renderTemplateFlow(localTemplateCopy);
            }
        };

        // Ir a la plantilla
        window.goToTemplate = function() {
            if (selectedTemplate) {
                window.location.href = `editor-plantillas.html?id=${selectedTemplate.id}`;
            }
        };

        // Guardar flujo como plantilla
        window.saveAsTemplate = function() {
            if (!localTemplateCopy || !localTemplateCopy.realContent) {
                if (typeof showToast === 'function') {
                    showToast('warning', 'No hay flujo para guardar');
                }
                return;
            }

            // Configurar callback global para el modal
            window.modalFormCallback = function(formData) {
                const { templateName, templateCategory } = formData;
                
                // Crear la plantilla con el flujo actual
                const nuevaPlantilla = {
                    id: 'template-' + Date.now(),
                    name: templateName.trim(),
                    category: templateCategory,
                    status: 'available', // Guardar como disponible para que aparezca en el selector
                    createdAt: new Date().toISOString(),
                    lastModified: new Date().toISOString().split('T')[0],
                    author: 'Usuario',
                    avatar: 'images/Profile-image.jpg',
                    version: 1,
                    stages: localTemplateCopy.realContent.stages ? localTemplateCopy.realContent.stages.length : 0,
                    agents: localTemplateCopy.realContent.stages ? localTemplateCopy.realContent.stages.filter(s => s.type === 'agent').length : 0,
                    realContent: {
                        stages: localTemplateCopy.realContent.stages ? JSON.parse(JSON.stringify(localTemplateCopy.realContent.stages)) : []
                    }
                };
                
                // Guardar en localStorage
                let templates = JSON.parse(localStorage.getItem('templates') || '[]');
                templates.push(nuevaPlantilla);
                localStorage.setItem('templates', JSON.stringify(templates));
                
                // Actualizar la lista de plantillas disponibles
                allTemplates = templates;
                
                // Actualizar el selector para incluir la nueva plantilla y seleccionarla automáticamente
                createTemplateSelect(nuevaPlantilla.id);
                
                // Seleccionar la plantilla recién guardada para mostrar su flujo
                selectedTemplate = nuevaPlantilla;
                localTemplateCopy = JSON.parse(JSON.stringify(nuevaPlantilla));
                
                // Cambiar a modo vista (no edición) ya que es una plantilla guardada
                isEditMode = false;
                const libraryWidget = document.getElementById('library-widget');
                const flowSection = document.getElementById('template-flow-section');
                if (libraryWidget) {
                    libraryWidget.style.display = 'none'; // Ocultar biblioteca en modo vista
                }
                if (flowSection) {
                    flowSection.className = 'section-single'; // Solo mostrar el flujo en modo vista
                    flowSection.style.display = 'flex';
                }
                
                // Renderizar el flujo de la plantilla guardada
                renderTemplateFlow(localTemplateCopy);
                applyEditMode();
                
                // Mostrar confirmación con toast UBITS
                if (typeof showToast === 'function') {
                    showToast('success', 'Plantilla guardada exitosamente');
                }
            };
            
            // Mostrar modal UBITS oficial con inputs oficiales
            showFormModal({
                title: 'Guardar como plantilla',
                message: 'Completa los datos para guardar este flujo como una plantilla reutilizable',
                fields: [
                    {
                        id: 'templateName',
                        label: 'Nombre de la plantilla',
                        type: 'text',
                        placeholder: 'Ej: Flujo de contratación general',
                        required: true,
                        maxLength: 100,
                        size: 'md'
                    },
                    {
                        id: 'templateCategory',
                        label: 'Categoría',
                        type: 'select',
                        placeholder: 'Selecciona una categoría',
                        required: true,
                        size: 'md',
                        selectOptions: [
                            {value: 'administracion', text: 'Administración'},
                            {value: 'atencion-cliente', text: 'Atención al cliente'},
                            {value: 'contratacion-general', text: 'Contratación general'},
                            {value: 'diseno-creatividad', text: 'Diseño y creatividad'},
                            {value: 'finanzas-contabilidad', text: 'Finanzas y contabilidad'},
                            {value: 'ingenieria', text: 'Ingeniería'},
                            {value: 'operaciones', text: 'Operaciones'},
                            {value: 'reclutamiento', text: 'Recursos humanos'},
                            {value: 'tecnologia-desarrollo', text: 'Tecnología / Desarrollo'},
                            {value: 'ventas-marketing', text: 'Ventas y marketing'}
                        ]
                    }
                ],
                submitText: 'Guardar plantilla',
                cancelText: 'Cancelar',
                onSubmit: function(formData) {
                    window.modalFormCallback(formData);
                },
                onCancel: function() {
                    console.log('Guardar plantilla cancelado');
                }
            });
        };

        // Renderizar tarjeta de agente (igual que en el editor)
        function renderAgentStageCard(stage, index, template) {
            const agentData = AGENTS.find(a => a.id === stage.agentId);
            if (!agentData) {
                return '';
            }

            // Descripción corta para mostrar en la card
            const agentDescriptions = {
                'cv-analyzer': 'Analiza CV y asigna puntaje',
                'interview-ia': 'Genera preguntas y analiza respuestas',
                'psychometric-analyst': 'Evalúa mediante pruebas psicométricas',
                'background-check': 'Verifica certificado de antecedentes judiciales'
            };
            const agentDescription = agentDescriptions[stage.agentId] || agentData.description;
            
            // Descripción larga para el tooltip del botón de información
            const agentTooltips = {
                'cv-analyzer': 'Este agente revisa automáticamente los CV, evalúa la experiencia del candidato y verifica que su expectativa salarial esté alineada con el rango de la vacante.',
                'interview-ia': 'Esta IA realiza entrevistas automáticas por teléfono o entrevista virtual, analiza las respuestas del candidato y asigna un puntaje según sus competencias y forma de responder.',
                'psychometric-analyst': 'Este agente aplica pruebas psicométricas al candidato y calcula un puntaje que refleja sus capacidades cognitivas y/o rasgos relevantes para el puesto.',
                'background-check': 'Permite generar y verificar el certificado de antecedentes judiciales del candidato para validar su historial legal de forma segura.'
            };
            const agentTooltip = agentTooltips[stage.agentId] || agentDescription;

            // Obtener categoría
            const categoryName = stage.category || 'Sin categoría';

            // Estado de expandido/contraído
            const isExpanded = stage.expanded || false;
            const configClass = isExpanded ? 'expanded' : '';
            const chevronIcon = isExpanded ? 'fa-chevron-up' : 'fa-chevron-down';

            // Descripción y resumen de configuración para modo vista
            let viewModeDescription = '';
            if (!isEditMode) {
                // Descripción del agente
                viewModeDescription = `
                    <div class="stage-description">
                        ${agentDescription}
                    </div>
                `;

                // Resumen de configuración si tiene config
                if (agentData.hasConfig && agentData.config && stage.config) {
                    let configSummary = '';

                    // Caso especial: Analista psicométrico - mostrar cantidad y tipos de pruebas
                    if (stage.agentId === 'psychometric-analyst') {
                        const tests = stage.config.tests || [];
                        const testsCount = tests.length;
                        const testsTypes = tests.map(test => {
                            const testType = agentData.testTypes?.find(t => t.value === test.type);
                            return testType ? testType.text : test.type;
                        }).join(', ');

                        configSummary = `
                            <div class="config-summary-item">
                                <span class="config-summary-label">Cantidad de pruebas:</span>
                                <span class="config-summary-value">${testsCount}</span>
                            </div>
                        `;

                        if (testsTypes) {
                            configSummary += `
                                <div class="config-summary-item">
                                    <span class="config-summary-label">Tipos de pruebas:</span>
                                    <span class="config-summary-value">${testsTypes}</span>
                                </div>
                            `;
                        }

                        // Puntaje mínimo global
                        const minScore = stage.config.minScore ?? agentData.config.minScore?.default ?? 0;
                        configSummary += `
                            <div class="config-summary-item">
                                <span class="config-summary-label">${agentData.config.minScore?.label || 'Puntaje mínimo global'}:</span>
                                <span class="config-summary-value">${minScore}${agentData.config.minScore?.suffix || 'pts'}</span>
                            </div>
                        `;
                    }
                    // Caso especial: Entrevista Serena - mostrar tipo de entrevista y voz
                    else if (stage.agentId === 'interview-ia') {
                        // Tipo de entrevista
                        const interviewType = stage.config.interviewType ?? agentData.config.interviewType?.default ?? 'telefonica';
                        const interviewTypeOption = agentData.config.interviewType?.options?.find(opt => opt.value === interviewType);
                        const interviewTypeText = interviewTypeOption ? interviewTypeOption.text : interviewType;

                        configSummary = `
                            <div class="config-summary-item">
                                <span class="config-summary-label">${agentData.config.interviewType?.label || 'Tipo de entrevista'}:</span>
                                <span class="config-summary-value">${interviewTypeText}</span>
                            </div>
                        `;

                        // Voz de Serena
                        const voice = stage.config.voice ?? agentData.config.voice?.default ?? 'colombia';
                        const voiceOption = agentData.voices?.find(v => v.id === voice);
                        const voiceText = voiceOption ? `${voiceOption.flag} ${voiceOption.name}` : voice;

                        configSummary += `
                            <div class="config-summary-item">
                                <span class="config-summary-label">${agentData.config.voice?.label || 'Voz de Serena'}:</span>
                                <span class="config-summary-value">${voiceText}</span>
                            </div>
                        `;

                        // Días de expiración y puntaje mínimo
                        const expirationDays = stage.config.expirationDays ?? agentData.config.expirationDays?.default ?? 0;
                        const minScore = stage.config.minScore ?? agentData.config.minScore?.default ?? 0;

                        configSummary += `
                            <div class="config-summary-item">
                                <span class="config-summary-label">${agentData.config.expirationDays?.label || 'Días para que expire la entrevista'}:</span>
                                <span class="config-summary-value">${expirationDays}${agentData.config.expirationDays?.suffix || 'días'}</span>
                            </div>
                            <div class="config-summary-item">
                                <span class="config-summary-label">${agentData.config.minScore?.label || 'Puntaje mínimo de la entrevista'}:</span>
                                <span class="config-summary-value">${minScore}${agentData.config.minScore?.suffix || 'pts'}</span>
                            </div>
                        `;
                    }
                    // Otros agentes - resumen normal
                    else {
                        configSummary = Object.entries(agentData.config)
                            .filter(([key]) => key !== 'tests')
                            .map(([key, field]) => {
                                const value = stage.config[key] ?? field.default;
                                let displayValue = value;

                                if (field.type === 'radio') {
                                    const option = field.options?.find(opt => opt.value === value);
                                    displayValue = option ? option.text : value;
                                } else if (field.type === 'number') {
                                    displayValue = value !== null && value !== undefined ? value : field.default || 0;
                                } else if (field.type === 'select') {
                                    const option = field.options?.find(opt => opt.value === value);
                                    displayValue = option ? option.text : value;
                                } else {
                                    displayValue = value !== null && value !== undefined ? value : '-';
                                }

                                return `
                                    <div class="config-summary-item">
                                        <span class="config-summary-label">${field.label}:</span>
                                        <span class="config-summary-value">${displayValue}${field.suffix || ''}</span>
                                    </div>
                                `;
                            })
                            .join('');
                    }

                    if (configSummary) {
                        viewModeDescription += `
                            <div class="stage-config-summary">
                                ${configSummary}
                            </div>
                        `;
                    }
                }
            }

            // Renderizar configuración si el agente tiene config (solo en modo edición)
            // Excluir psychometric-analyst (tiene drawer) e interview-ia (tiene drawer)
            let configHTML = '';
            if (isEditMode && agentData.hasConfig && agentData.config && stage.agentId !== 'psychometric-analyst' && stage.agentId !== 'interview-ia') {
                configHTML = `
                    ${isExpanded ? '<div class="agent-stage-divider"></div>' : ''}
                    <div class="agent-stage-config ${configClass}" id="agent-config-${stage.id}">
                        ${Object.entries(agentData.config).map(([key, field]) => {
                            const value = stage.config?.[key] ?? field.default;
                            
                            if (field.type === 'number') {
                                return `
                                    <div class="config-field">
                                        <label class="config-label">
                                            ${field.label}
                                            ${field.tooltip ? `
                                                <button type="button" class="config-info-btn" 
                                                        data-tooltip="${(field.tooltip || '').replace(/"/g, '&quot;')}"
                                                        title="${(field.tooltip || '').replace(/"/g, '&quot;')}">
                                                    <i class="far fa-circle-info"></i>
                                                </button>
                                            ` : ''}
                                        </label>
                                        <div class="config-input-group">
                                            <input 
                                                type="number" 
                                                class="config-input" 
                                                value="${value}"
                                                min="0"
                                                onchange="updateAgentStageConfig('${stage.id}', '${key}', this.value)"
                                            >
                                            ${field.suffix ? `<span class="config-suffix">${field.suffix}</span>` : ''}
                                        </div>
                                    </div>
                                `;
                            } else if (field.type === 'radio') {
                                return `
                                    <div class="config-field config-field-radio">
                                        <label class="config-label">
                                            ${field.label}
                                        </label>
                                        <div class="config-radio-group">
                                            ${field.options ? field.options.map(opt => `
                                                <label class="config-radio-label">
                                                    <input 
                                                        type="radio" 
                                                        name="config-${stage.id}-${key}"
                                                        value="${opt.value}"
                                                        ${value === opt.value ? 'checked' : ''}
                                                        onchange="updateAgentStageConfig('${stage.id}', '${key}', this.value)"
                                                    >
                                                    <span>${opt.text}</span>
                                                </label>
                                            `).join('') : ''}
                                        </div>
                                    </div>
                                `;
                            }
                            return '';
                        }).join('')}
                    </div>
                `;
            }

            return `
                <div class="stage-item agent-stage-item" draggable="true" data-stage-id="${stage.id}" data-stage-index="${index}" data-stage-type="agent">
                    <i class="far fa-grip-vertical stage-drag-handle"></i>
                    <div class="stage-content">
                        <div class="stage-header agent-stage-header">
                            <div class="stage-title-section">
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <div class="stage-number">${index + 1}</div>
                                    <div>
                                        <h4 class="stage-name">${stage.name} (IA)</h4>
                                        <span class="stage-category-badge">Categoría de etapa: ${categoryName}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="stage-actions">
                                ${agentData.hasConfig && stage.agentId === 'psychometric-analyst' ? `
                                    <button class="ubits-button ubits-button--secondary ubits-button--sm" onclick="openPsychometricTestsDrawer('${stage.id}')" title="Pruebas psicotécnicas">
                                        <i class="far fa-list"></i>
                                        <span>Pruebas (${stage.config?.tests?.length || 0})</span>
                                    </button>
                                ` : agentData.hasConfig && stage.agentId === 'interview-ia' ? `
                                    <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only" onclick="openSerenaConfigDrawer('${stage.id}')" title="Configurar entrevista Serena">
                                        <i class="far fa-gear"></i>
                                    </button>
                                ` : agentData.hasConfig && stage.agentId !== 'psychometric-analyst' && stage.agentId !== 'interview-ia' ? `
                                    <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only ${isExpanded ? 'ubits-button--active' : ''}" onclick="toggleAgentStageConfig('${stage.id}')" title="Expandir/Contraer configuración">
                                        <i class="far fa-gear" id="chevron-${stage.id}"></i>
                                    </button>
                                ` : ''}
                                ${index > 0 ? `
                                    <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only" onclick="moveAgentStageUp('${stage.id}')" title="Subir">
                                        <i class="far fa-arrow-up"></i>
                                    </button>
                                ` : ''}
                                ${index < template.realContent.stages.length - 1 ? `
                                    <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only" onclick="moveAgentStageDown('${stage.id}')" title="Bajar">
                                        <i class="far fa-arrow-down"></i>
                                    </button>
                                ` : ''}
                                <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only" onclick="deleteAgentStage('${stage.id}')" title="Quitar agente" style="color: var(--ubits-feedback-accent-error);">
                                    <i class="far fa-trash"></i>
                                </button>
                                <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only agent-info-btn"
                                        data-agent-id="${stage.agentId}"
                                        data-agent-name="${agentData.name}"
                                        data-agent-description="${agentTooltip.replace(/"/g, '&quot;')}"
                                        title="Ver más información">
                                    <i class="far fa-circle-info"></i>
                                </button>
                            </div>
                        </div>
                        ${viewModeDescription}
                        ${configHTML}
                    </div>
                </div>
            `;
        }

        // Renderizar tarjeta de etapa personalizada
        function renderCustomStageCard(stage, index, template) {
            const stageName = stage.name || 'Etapa sin nombre';
            const categoryName = stage.category || 'Sin categoría';
            
            // Descripción para modo vista
            let viewModeDescription = '';
            if (!isEditMode && stage.description) {
                viewModeDescription = `
                    <div class="stage-description">
                        ${stage.description}
                    </div>
                `;
            }
            
            return `
                <div class="stage-item custom-stage-item" draggable="true" data-stage-id="${stage.id}" data-stage-index="${index}" data-stage-type="custom">
                    <i class="far fa-grip-vertical stage-drag-handle"></i>
                    <div class="stage-content">
                        <div class="stage-header">
                            <div class="stage-title-section">
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <div class="stage-number">${index + 1}</div>
                                    <div>
                                        <h4 class="stage-name">${stageName}</h4>
                                        <span class="stage-category-badge">Categoría de etapa: ${categoryName}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="stage-actions">
                                ${index > 0 ? `
                                    <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only" onclick="moveAgentStageUp('${stage.id}')" title="Subir">
                                        <i class="far fa-arrow-up"></i>
                                    </button>
                                ` : ''}
                                ${index < template.realContent.stages.length - 1 ? `
                                    <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only" onclick="moveAgentStageDown('${stage.id}')" title="Bajar">
                                        <i class="far fa-arrow-down"></i>
                                    </button>
                                ` : ''}
                                <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only" onclick="deleteAgentStage('${stage.id}')" title="Quitar etapa" style="color: var(--ubits-feedback-accent-error);">
                                    <i class="far fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        ${viewModeDescription}
                    </div>
                </div>
            `;
        }

        // Ocultar el flujo de la plantilla
        function hideTemplateFlow() {
            const flowSection = document.getElementById('template-flow-section');
            if (flowSection) {
                flowSection.style.display = 'none';
            }
            selectedTemplate = null;
            localTemplateCopy = null;
        }

        // Crear inputs UBITS para campos select en configuración
        function createConfigInputs(template) {
            template.realContent.stages.forEach(stage => {
                if (stage.type === 'agent' && stage.agentId) {
                    const agentData = AGENTS.find(a => a.id === stage.agentId);
                    if (agentData && agentData.config) {
                        Object.entries(agentData.config).forEach(([key, field]) => {
                            if (field.type === 'select') {
                                const containerId = `config-${stage.id}-${key}`;
                                const container = document.getElementById(containerId);
                                if (container) {
                                    const value = stage.config?.[key] ?? field.default;
                                    createInput({
                                        containerId: containerId,
                                        type: 'select',
                                        placeholder: field.placeholder || 'Selecciona...',
                                        selectOptions: field.options || [],
                                        value: value,
                                        onChange: function(newValue) {
                                            updateAgentStageConfig(stage.id, key, newValue);
                                        }
                                    });
                                }
                            }
                        });
                    }
                }
            });
        }

        // Funciones de edición (disponibles globalmente)
        window.toggleAgentStageConfig = function(stageId) {
            if (!localTemplateCopy || !isEditMode) return;
            const stage = localTemplateCopy.realContent.stages.find(s => s.id === stageId);
            if (!stage) return;

            stage.expanded = !stage.expanded;
            
            // Actualizar visualmente sin re-renderizar todo
            const configDiv = document.getElementById(`agent-config-${stageId}`);
            const chevron = document.getElementById(`chevron-${stageId}`);
            
            if (configDiv) {
                if (stage.expanded) {
                    configDiv.classList.add('expanded');
                    // Agregar divider si no existe
                    if (!configDiv.previousElementSibling || !configDiv.previousElementSibling.classList.contains('agent-stage-divider')) {
                        const divider = document.createElement('div');
                        divider.className = 'agent-stage-divider';
                        configDiv.parentNode.insertBefore(divider, configDiv);
                    }
                    
                    // Agregar event listeners para tooltips cuando se expande
                    setTimeout(() => {
                        configDiv.querySelectorAll('.config-info-btn').forEach(btn => {
                            // Remover listeners previos si existen para evitar duplicados
                            btn.removeEventListener('mouseenter', handleConfigInfoHover);
                            btn.removeEventListener('mouseleave', handleConfigInfoLeave);
                            // Agregar nuevos listeners
                            btn.addEventListener('mouseenter', handleConfigInfoHover);
                            btn.addEventListener('mouseleave', handleConfigInfoLeave);
                        });
                    }, 50);
                } else {
                    configDiv.classList.remove('expanded');
                    // Remover divider
                    const divider = configDiv.previousElementSibling;
                    if (divider && divider.classList.contains('agent-stage-divider')) {
                        divider.remove();
                    }
                }
            }
            
            if (chevron) {
                // El icono siempre es fa-gear, solo cambia el estado activo del botón
                chevron.className = 'far fa-gear';
            }
        };

        window.updateAgentStageConfig = function(stageId, configKey, value) {
            if (!localTemplateCopy || !isEditMode) return;
            const stage = localTemplateCopy.realContent.stages.find(s => s.id === stageId);
            if (!stage || !stage.config) return;

            const agentData = AGENTS.find(a => a.id === stage.agentId);
            if (agentData && agentData.config && agentData.config[configKey]) {
                const field = agentData.config[configKey];
                if (field.type === 'number') {
                    stage.config[configKey] = parseFloat(value) || 0;
                } else {
                    stage.config[configKey] = value;
                }
            } else {
                stage.config[configKey] = value;
            }

            // Re-renderizar solo la configuración de este stage
            const configDiv = document.getElementById(`agent-config-${stageId}`);
            if (configDiv && stage.expanded) {
                // Actualizar el valor en el input sin re-renderizar todo
                const input = configDiv.querySelector(`input[onchange*="${configKey}"]`);
                if (input) {
                    input.value = value;
                }
            }
        };

        window.deleteAgentStage = function(stageId) {
            if (!localTemplateCopy || !isEditMode) return;
            
            // Determinar si es una etapa o un agente IA
            const stage = localTemplateCopy.realContent.stages.find(s => s.id === stageId);
            const isAgent = stage && stage.type === 'agent';
            const stageType = isAgent ? 'asistente IA' : 'etapa';
            const actionText = isAgent ? 'Quitar asistente IA' : 'Quitar etapa';
            const messageText = isAgent ? '¿Estás seguro de que quieres quitar este asistente IA del flujo?' : '¿Estás seguro de que quieres quitar esta etapa del flujo?';
            const successMessage = isAgent ? 'Asistente IA quitado del flujo' : 'Etapa quitada del flujo';
            
            // Función para mover candidatos a la biblioteca
            const moveCandidatesToLibrary = function() {
                console.log('🔄 [moveCandidatesToLibrary] Iniciando búsqueda de candidatos...');
                console.log('🔍 [moveCandidatesToLibrary] Etapa a eliminar:', stageId);
                
                try {
                    // Buscar la primera etapa disponible (biblioteca) después de eliminar la etapa actual
                    const remainingStages = localTemplateCopy.realContent.stages.filter(s => s.id !== stageId);
                    const libraryStageId = remainingStages.length > 0 ? remainingStages[0].id : null;
                    console.log('📚 [moveCandidatesToLibrary] Primera etapa disponible (biblioteca):', libraryStageId);
                    
                    if (!libraryStageId) {
                        console.warn('⚠️ [moveCandidatesToLibrary] No hay etapas disponibles después de eliminar esta etapa');
                    }
                    
                    // Buscar TODAS las claves en localStorage que puedan contener candidatos
                    const allKeys = Object.keys(localStorage);
                    console.log('🔍 [moveCandidatesToLibrary] Total de claves en localStorage:', allKeys.length);
                    
                    // Filtrar claves que podrían contener candidatos
                    const candidateKeys = allKeys.filter(key => {
                        // Excluir claves conocidas que no son candidatos
                        const excludedKeys = ['templates', 'availableStages', 'availableAgents', 'theme', 'language'];
                        if (excludedKeys.includes(key)) return false;
                        
                        // Incluir claves que mencionan candidatos, aplicantes, o vacantes
                        const lowerKey = key.toLowerCase();
                        return lowerKey.includes('candidate') || 
                               lowerKey.includes('applicant') || 
                               lowerKey.includes('vacant') ||
                               lowerKey.includes('job') ||
                               lowerKey.includes('recruitment') ||
                               lowerKey.includes('hiring');
                    });
                    
                    console.log('🔍 [moveCandidatesToLibrary] Claves candidatas encontradas:', candidateKeys);
                    
                    let candidatesMoved = 0;
                    
                    // Función recursiva para buscar candidatos en cualquier estructura
                    const findAndMoveCandidates = function(obj, path = '') {
                        if (!obj || typeof obj !== 'object') return;
                        
                        // Si es un array, buscar candidatos dentro
                        if (Array.isArray(obj)) {
                            obj.forEach((item, index) => {
                                if (item && typeof item === 'object') {
                                    // Verificar si es un candidato (tiene propiedades de etapa)
                                    const hasStageInfo = 'currentStageId' in item || 
                                                         'stageId' in item || 
                                                         'stage' in item ||
                                                         'currentStage' in item ||
                                                         'stageName' in item;
                                    
                                    if (hasStageInfo) {
                                        const candidateStageId = item.currentStageId || item.stageId || item.stage || item.currentStage;
                                        
                                        if (candidateStageId === stageId) {
                                            console.log(`✅ [moveCandidatesToLibrary] Candidato encontrado en ${path}[${index}]:`, item);
                                            
                                            // Mover a la biblioteca (primera etapa disponible)
                                            if (libraryStageId) {
                                                if ('currentStageId' in item) item.currentStageId = libraryStageId;
                                                if ('stageId' in item) item.stageId = libraryStageId;
                                                if ('stage' in item) item.stage = libraryStageId;
                                                if ('currentStage' in item) item.currentStage = libraryStageId;
                                            } else {
                                                // Si no hay etapas disponibles, poner en null
                                                if ('currentStageId' in item) item.currentStageId = null;
                                                if ('stageId' in item) item.stageId = null;
                                                if ('stage' in item) item.stage = null;
                                                if ('currentStage' in item) item.currentStage = null;
                                            }
                                            candidatesMoved++;
                                        }
                                    }
                                    
                                    // Buscar recursivamente dentro del objeto
                                    findAndMoveCandidates(item, `${path}[${index}]`);
                                }
                            });
                        } else {
                            // Si es un objeto, buscar en sus propiedades
                            Object.keys(obj).forEach(key => {
                                const value = obj[key];
                                if (value && typeof value === 'object') {
                                    findAndMoveCandidates(value, path ? `${path}.${key}` : key);
                                }
                            });
                        }
                    };
                    
                    // Procesar cada clave que podría contener candidatos
                    candidateKeys.forEach(key => {
                        try {
                            const stored = localStorage.getItem(key);
                            if (!stored) return;
                            
                            let data = null;
                            try {
                                data = JSON.parse(stored);
                            } catch (e) {
                                // No es JSON, saltar
                                return;
                            }
                            
                            if (!data) return;
                            
                            console.log(`🔍 [moveCandidatesToLibrary] Procesando clave: ${key}`);
                            
                            // Buscar candidatos recursivamente
                            const beforeCount = candidatesMoved;
                            findAndMoveCandidates(data, key);
                            
                            if (candidatesMoved > beforeCount) {
                                // Guardar datos actualizados
                                localStorage.setItem(key, JSON.stringify(data));
                                console.log(`💾 [moveCandidatesToLibrary] Guardados cambios en ${key}`);
                            }
                        } catch (error) {
                            console.warn(`⚠️ [moveCandidatesToLibrary] Error procesando clave ${key}:`, error);
                        }
                    });
                    
                    // También buscar en todas las claves por si acaso (más exhaustivo)
                    if (candidatesMoved === 0) {
                        console.log('🔍 [moveCandidatesToLibrary] No se encontraron candidatos en claves específicas, buscando en todas las claves...');
                        
                        allKeys.forEach(key => {
                            // Saltar claves conocidas que no son candidatos
                            if (['templates', 'availableStages', 'availableAgents', 'theme', 'language'].includes(key)) return;
                            
                            try {
                                const stored = localStorage.getItem(key);
                                if (!stored) return;
                                
                                let data = null;
                                try {
                                    data = JSON.parse(stored);
                                } catch (e) {
                                    return;
                                }
                                
                                if (!data || typeof data !== 'object') return;
                                
                                const beforeCount = candidatesMoved;
                                findAndMoveCandidates(data, key);
                                
                                if (candidatesMoved > beforeCount) {
                                    localStorage.setItem(key, JSON.stringify(data));
                                    console.log(`💾 [moveCandidatesToLibrary] Guardados cambios en ${key} (búsqueda exhaustiva)`);
                                }
                            } catch (error) {
                                // Silenciar errores en búsqueda exhaustiva
                            }
                        });
                    }
                    
                    if (candidatesMoved > 0) {
                        console.log(`✅ [moveCandidatesToLibrary] ${candidatesMoved} candidato(s) movido(s) a la biblioteca`);
                        if (typeof showToast === 'function') {
                            showToast('info', `${candidatesMoved} candidato(s) movido(s) a la biblioteca`);
                        }
                    } else {
                        console.log('ℹ️ [moveCandidatesToLibrary] No se encontraron candidatos en la etapa eliminada');
                    }
                } catch (error) {
                    console.error('❌ [moveCandidatesToLibrary] Error al mover candidatos a la biblioteca:', error);
                }
            };
            
            if (typeof showConfirmModal === 'function') {
                showConfirmModal({
                    title: actionText,
                    message: messageText,
                    confirmText: 'Quitar',
                    cancelText: 'Cancelar',
                    variant: 'primary',
                    onConfirm: () => {
                        // Mover candidatos a la biblioteca antes de eliminar la etapa
                        moveCandidatesToLibrary();
                        
                        // Si la etapa tiene templateId, asegurarse de que esté disponible en la biblioteca
                        if (stage && stage.templateId) {
                            const templateStageId = stage.templateId;
                            const existsInLibrary = availableStages.find(s => s.id === templateStageId);
                            
                            if (!existsInLibrary) {
                                // Buscar la etapa original en availableStages (puede que se haya eliminado)
                                // Si no existe, recrearla con los datos de la etapa eliminada
                                const stageToAdd = {
                                    id: templateStageId,
                                    name: stage.name,
                                    category: stage.category,
                                    type: stage.type || 'custom',
                                    description: stage.description || '',
                                    createdAt: stage.createdAt || new Date().toISOString(),
                                    isDefault: stage.isDefault || false
                                };
                                
                                availableStages.push(stageToAdd);
                                saveAvailableStages();
                                console.log('✅ [deleteAgentStage] Etapa devuelta a la biblioteca:', stageToAdd.name);
                                
                                // Re-renderizar la biblioteca para que aparezca la etapa
                                setTimeout(() => {
                                    const activeTab = document.querySelector('#agents-sidebar .tab-button.active');
                                    if (activeTab) {
                                        const tabType = activeTab.dataset.tab;
                                        if (tabType === 'stages') {
                                            if (typeof renderAvailableStages === 'function') {
                                                renderAvailableStages();
                                            } else if (typeof renderStages === 'function') {
                                                renderStages();
                                            }
                                        }
                                    }
                                }, 150);
                            } else {
                                console.log('ℹ️ [deleteAgentStage] La etapa ya existe en la biblioteca');
                                // Aún así, re-renderizar para asegurar que se muestre
                                setTimeout(() => {
                                    const activeTab = document.querySelector('#agents-sidebar .tab-button.active');
                                    if (activeTab && activeTab.dataset.tab === 'stages') {
                                        if (typeof renderAvailableStages === 'function') {
                                            renderAvailableStages();
                                        } else if (typeof renderStages === 'function') {
                                            renderStages();
                                        }
                                    }
                                }, 150);
                            }
                        } else {
                            console.log('ℹ️ [deleteAgentStage] La etapa no tiene templateId (puede ser un agente o etapa creada directamente)');
                        }
                        
                        localTemplateCopy.realContent.stages = localTemplateCopy.realContent.stages.filter(s => s.id !== stageId);
                        renderTemplateFlow(localTemplateCopy);
                        
                        // Si es un agente IA, re-renderizar la biblioteca de agentes para que vuelva a aparecer
                        if (isAgent) {
                            setTimeout(() => {
                                if (typeof renderAgents === 'function') {
                                    renderAgents();
                                    console.log('✅ [deleteAgentStage] Biblioteca de agentes re-renderizada');
                                }
                            }, 150);
                        }
                        
                        // Actualizar stepper después de un pequeño delay para asegurar que el DOM se actualizó
                        setTimeout(() => {
                            updateStepper();
                        }, 100);
                        if (typeof showToast === 'function') {
                            showToast('success', successMessage);
                        }
                    }
                });
            } else {
                if (confirm(messageText)) {
                    // Mover candidatos a la biblioteca antes de eliminar la etapa
                    moveCandidatesToLibrary();
                    
                    // Si la etapa tiene templateId, asegurarse de que esté disponible en la biblioteca
                    if (stage && stage.templateId) {
                        const templateStageId = stage.templateId;
                        const existsInLibrary = availableStages.find(s => s.id === templateStageId);
                        
                        if (!existsInLibrary) {
                            // Buscar la etapa original en availableStages (puede que se haya eliminado)
                            // Si no existe, recrearla con los datos de la etapa eliminada
                            const stageToAdd = {
                                id: templateStageId,
                                name: stage.name,
                                category: stage.category,
                                type: stage.type || 'custom',
                                description: stage.description || '',
                                createdAt: stage.createdAt || new Date().toISOString(),
                                isDefault: stage.isDefault || false
                            };
                            
                            availableStages.push(stageToAdd);
                            saveAvailableStages();
                            console.log('✅ [deleteAgentStage] Etapa devuelta a la biblioteca:', stageToAdd.name);
                            
                            // Re-renderizar la biblioteca para que aparezca la etapa
                            setTimeout(() => {
                                const activeTab = document.querySelector('#agents-sidebar .tab-button.active');
                                if (activeTab) {
                                    const tabType = activeTab.dataset.tab;
                                    if (tabType === 'stages') {
                                        if (typeof renderAvailableStages === 'function') {
                                            renderAvailableStages();
                                        } else if (typeof renderStages === 'function') {
                                            renderStages();
                                        }
                                    }
                                }
                            }, 150);
                        } else {
                            console.log('ℹ️ [deleteAgentStage] La etapa ya existe en la biblioteca');
                            // Aún así, re-renderizar para asegurar que se muestre
                            setTimeout(() => {
                                const activeTab = document.querySelector('#agents-sidebar .tab-button.active');
                                if (activeTab && activeTab.dataset.tab === 'stages') {
                                    if (typeof renderAvailableStages === 'function') {
                                        renderAvailableStages();
                                    } else if (typeof renderStages === 'function') {
                                        renderStages();
                                    }
                                }
                            }, 150);
                        }
                    } else {
                        console.log('ℹ️ [deleteAgentStage] La etapa no tiene templateId (puede ser un agente o etapa creada directamente)');
                    }
                    
                    localTemplateCopy.realContent.stages = localTemplateCopy.realContent.stages.filter(s => s.id !== stageId);
                    renderTemplateFlow(localTemplateCopy);
                    
                    // Si es un agente IA, re-renderizar la biblioteca de agentes para que vuelva a aparecer
                    if (isAgent) {
                        setTimeout(() => {
                            if (typeof renderAgents === 'function') {
                                renderAgents();
                                console.log('✅ [deleteAgentStage] Biblioteca de agentes re-renderizada');
                            }
                        }, 150);
                    }
                    
                    // Actualizar stepper después de un pequeño delay para asegurar que el DOM se actualizó
                    setTimeout(() => {
                        updateStepper();
                    }, 100);
                    if (typeof showToast === 'function') {
                        showToast('success', successMessage);
                    }
                }
            }
        };

        window.moveAgentStageUp = function(stageId) {
            if (!localTemplateCopy || !isEditMode) return;
            const stages = localTemplateCopy.realContent.stages;
            const index = stages.findIndex(s => s.id === stageId);
            if (index > 0) {
                [stages[index - 1], stages[index]] = [stages[index], stages[index - 1]];
                renderTemplateFlow(localTemplateCopy);
            }
        };

        window.moveAgentStageDown = function(stageId) {
            if (!localTemplateCopy || !isEditMode) return;
            const stages = localTemplateCopy.realContent.stages;
            const index = stages.findIndex(s => s.id === stageId);
            if (index < stages.length - 1) {
                [stages[index], stages[index + 1]] = [stages[index + 1], stages[index]];
                renderTemplateFlow(localTemplateCopy);
            }
        };

        // Crear input de días con UBITS Input
        function createDaysInput() {
            createInput({
                containerId: 'days-input-container',
                label: 'Enviar correo de rechazo a los: (días)',
                type: 'number',
                placeholder: '3',
                value: '3',
                onChange: function(value) {
                    console.log('Days value:', value);
                }
            });
        }

        // Renderizar etapas en la biblioteca
        // Etapas por defecto
        const DEFAULT_STAGES = [
            // Categoría: Evaluación inicial
            {
                id: 'default-review-cv',
                name: 'Revisión de CV',
                category: 'evaluacion-inicial',
                type: 'custom',
                description: 'Revisión del currículum para validar experiencia, formación y requisitos mínimos del cargo.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-pre-filter-requirements',
                name: 'Pre-filtro de requisitos mínimos',
                category: 'evaluacion-inicial',
                type: 'custom',
                description: 'Validación rápida de criterios excluyentes: años de experiencia, nivel educativo, idioma, país/ciudad, etc.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            // Categoría: Entrevistas
            {
                id: 'default-interview-pre-screening',
                name: 'Entrevista de pre-screening',
                category: 'entrevistas',
                type: 'custom',
                description: 'Primera conversación breve (teléfono o videollamada) para validar interés, motivación y puntos clave del perfil.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-interview-recruiter',
                name: 'Entrevista con reclutador',
                category: 'entrevistas',
                type: 'custom',
                description: 'Entrevista más profunda para evaluar competencias blandas, expectativas y encaje general con la empresa.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-interview-hiring-manager',
                name: 'Entrevista con el área / hiring manager',
                category: 'entrevistas',
                type: 'custom',
                description: 'Entrevista técnica o funcional con el responsable del área para evaluar ajuste al rol.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-interview-technical',
                name: 'Entrevista técnica',
                category: 'entrevistas',
                type: 'custom',
                description: 'Conversación enfocada en conocimientos técnicos, metodologías de trabajo y experiencia práctica.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-interview-final',
                name: 'Entrevista final',
                category: 'entrevistas',
                type: 'custom',
                description: 'Última entrevista con dirección o stakeholders clave antes de la decisión definitiva.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            // Categoría: Evaluación psicométrica
            {
                id: 'default-psychometric-general',
                name: 'Evaluación psicométrica general',
                category: 'evaluacion-psicometrica',
                type: 'custom',
                description: 'Batería estándar de pruebas para medir habilidades cognitivas y rasgos de personalidad relevantes.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-test-cognitive',
                name: 'Test de habilidades cognitivas',
                category: 'evaluacion-psicometrica',
                type: 'custom',
                description: 'Mide razonamiento lógico, numérico, verbal u otras capacidades cognitivas.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-test-personality',
                name: 'Test de personalidad laboral',
                category: 'evaluacion-psicometrica',
                type: 'custom',
                description: 'Evalúa rasgos de personalidad vinculados al estilo de trabajo, liderazgo y trabajo en equipo.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-test-soft-skills',
                name: 'Test de competencias blandas',
                category: 'evaluacion-psicometrica',
                type: 'custom',
                description: 'Mide competencias como comunicación, resolución de problemas, organización, manejo del estrés, etc.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            // Categoría: Pruebas técnicas
            {
                id: 'default-technical-general',
                name: 'Prueba técnica general',
                category: 'pruebas-tecnicas',
                type: 'custom',
                description: 'Evaluación de conocimientos técnicos básicos requeridos para el rol.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-case-practical',
                name: 'Caso práctico / Challenge',
                category: 'pruebas-tecnicas',
                type: 'custom',
                description: 'Ejercicio aplicado (ej. resolver un caso, diseñar una solución, elaborar una propuesta) para ver cómo trabaja la persona.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-test-specific-skills',
                name: 'Prueba de habilidades específicas',
                category: 'pruebas-tecnicas',
                type: 'custom',
                description: 'Prueba focalizada en una herramienta o skill concreta (por ejemplo: Excel avanzado, un CRM, un lenguaje de programación).',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-test-languages',
                name: 'Prueba de idiomas',
                category: 'pruebas-tecnicas',
                type: 'custom',
                description: 'Evaluación de comprensión y expresión oral/escrita en el idioma requerido por el puesto.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            // Categoría: Verificación
            {
                id: 'default-verify-references',
                name: 'Verificación de referencias laborales',
                category: 'verificacion',
                type: 'custom',
                description: 'Contacto y validación de referencias con jefes o empleadores anteriores.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-verify-background',
                name: 'Verificación de antecedentes judiciales',
                category: 'verificacion',
                type: 'custom',
                description: 'Revisión de antecedentes según la normativa del país y las políticas internas.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-verify-studies',
                name: 'Verificación de estudios y certificados',
                category: 'verificacion',
                type: 'custom',
                description: 'Confirmación de títulos académicos, cursos y certificaciones declaradas.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-verify-documents',
                name: 'Verificación de documentación',
                category: 'verificacion',
                type: 'custom',
                description: 'Revisión de documentos de identidad, permisos de trabajo u otros requisitos legales.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            // Categoría: Decisión final
            {
                id: 'default-final-review',
                name: 'Revisión final de candidatura',
                category: 'decision-final',
                type: 'custom',
                description: 'Etapa donde se consolidan evaluaciones y se define si el candidato avanza a oferta o se descarta.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-approval-offer',
                name: 'Aprobación para oferta',
                category: 'decision-final',
                type: 'custom',
                description: 'Marca al candidato como aprobado internamente y listo para recibir una propuesta.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-offer-sent',
                name: 'Oferta laboral enviada',
                category: 'decision-final',
                type: 'custom',
                description: 'Registro de que se envió la oferta formal (contrato, condiciones, salario, etc.).',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-offer-accepted',
                name: 'Oferta aceptada',
                category: 'decision-final',
                type: 'custom',
                description: 'Candidato acepta la oferta y se confirma su incorporación.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-process-closed',
                name: 'Proceso cerrado – no seleccionado',
                category: 'decision-final',
                type: 'custom',
                description: 'Cierre formal de candidatos descartados en cualquier etapa.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-talent-pool',
                name: 'Banco de talento',
                category: 'decision-final',
                type: 'custom',
                description: 'Candidatos que no fueron seleccionados para esta vacante, pero quedan guardados como potenciales para futuras posiciones.',
                createdAt: new Date().toISOString(),
                isDefault: true
            },
            {
                id: 'default-hired',
                name: 'Contratado',
                category: 'decision-final',
                type: 'custom',
                description: 'Candidato ha sido contratado y se ha incorporado exitosamente a la empresa.',
                createdAt: new Date().toISOString(),
                isDefault: true
            }
        ];

        // Cargar etapas desde localStorage
        function loadAvailableStages() {
            console.log('🔧 [loadAvailableStages] Iniciando...');
            const stored = localStorage.getItem('availableStages');
            console.log('🔧 [loadAvailableStages] stored:', stored ? 'existe' : 'no existe');
            if (stored) {
                const parsedStages = JSON.parse(stored);
                console.log('🔧 [loadAvailableStages] parsedStages.length:', parsedStages.length);
                // IDs de etapas por defecto que ya no deben existir (eliminadas)
                const removedDefaultStageIds = [
                    'default-pre-filter-salary',
                    'default-pre-filter-availability',
                    'default-interview-culture',
                    'default-verify-employment'
                ];
                
                // IDs de etapas por defecto actuales que deben existir
                const currentDefaultStageIds = DEFAULT_STAGES.map(s => s.id);
                
                // Filtrar etapas: eliminar las que ya no deben existir y las personalizadas
                const customStages = parsedStages.filter(s => !s.isDefault);
                const validDefaultStages = parsedStages.filter(s => 
                    s.isDefault && 
                    !removedDefaultStageIds.includes(s.id) && 
                    currentDefaultStageIds.includes(s.id)
                );
                
                // Identificar etapas por defecto que faltan
                const existingDefaultIds = validDefaultStages.map(s => s.id);
                const missingDefaultIds = currentDefaultStageIds.filter(id => !existingDefaultIds.includes(id));
                
                // Verificar si hay etapas obsoletas que eliminar
                const hasObsoleteStages = parsedStages.some(s => 
                    s.isDefault && removedDefaultStageIds.includes(s.id)
                );
                
                // Si faltan etapas por defecto o hay etapas obsoletas, actualizar
                if (missingDefaultIds.length > 0 || hasObsoleteStages || parsedStages.length !== (validDefaultStages.length + customStages.length)) {
                    if (missingDefaultIds.length > 0) {
                        console.log('⚠️ [loadAvailableStages] Faltan etapas por defecto:', missingDefaultIds.length);
                    }
                    if (hasObsoleteStages) {
                        console.log('🔄 [loadAvailableStages] Eliminando etapas obsoletas...');
                    }
                    
                    // Agregar las etapas por defecto que faltan
                    const missingDefaultStages = missingDefaultIds.length > 0 
                        ? DEFAULT_STAGES.filter(s => missingDefaultIds.includes(s.id))
                        : [];
                    
                    // Combinar: nuevas etapas por defecto + etapas válidas existentes + etapas personalizadas
                    availableStages = [...missingDefaultStages, ...validDefaultStages, ...customStages];
                    saveAvailableStages();
                    console.log('✅ [loadAvailableStages] Etapas actualizadas. Total:', availableStages.length);
                } else {
                    availableStages = parsedStages;
                    console.log('✅ [loadAvailableStages] Todas las etapas están actualizadas. Total:', availableStages.length);
                }
            } else {
                // Si no hay etapas guardadas, usar las por defecto
                availableStages = [...DEFAULT_STAGES];
                saveAvailableStages();
                console.log('✅ [loadAvailableStages] Etapas por defecto inicializadas');
            }
            console.log('🔧 [loadAvailableStages] availableStages.length final:', availableStages.length);
        }

        // Renderizar etapas disponibles
        function renderAvailableStages() {
            console.log('🔧 [renderAvailableStages] Iniciando...');
            const stagesList = document.getElementById('stagesList');
            console.log('🔧 [renderAvailableStages] stagesList:', stagesList);
            if (!stagesList) {
                console.error('❌ [renderAvailableStages] No se encontró stagesList');
                return;
            }
            
            // Cargar etapas si no están cargadas (solo si realmente no hay etapas)
            // NO recargar si acabamos de hacer una eliminación
            if (availableStages.length === 0) {
                const stored = localStorage.getItem('availableStages');
                if (stored) {
                    const parsed = JSON.parse(stored);
                    if (parsed.length > 0) {
                        // Hay etapas en localStorage pero no en la variable, recargar
                        console.log('🔧 [renderAvailableStages] Sincronizando con localStorage...');
                        loadAvailableStages();
                    } else {
                        // Realmente no hay etapas, cargar por defecto
                        console.log('🔧 [renderAvailableStages] No hay etapas, cargando por defecto...');
                        loadAvailableStages();
                    }
                } else {
                    // No hay nada en localStorage, cargar por defecto
                    console.log('🔧 [renderAvailableStages] No hay etapas en localStorage, cargando por defecto...');
                    loadAvailableStages();
                }
            }
            
            console.log('🔧 [renderAvailableStages] availableStages.length:', availableStages.length);
            console.log('🔧 [renderAvailableStages] localTemplateCopy:', localTemplateCopy);
            
            // Filtrar etapas que ya están en uso en esta plantilla
            const usedStageIds = localTemplateCopy?.realContent?.stages?.map(stage => stage.templateId).filter(id => id) || [];
            const availableStagesForThisTemplate = availableStages.filter(stage => !usedStageIds.includes(stage.id));
            console.log('🔧 [renderAvailableStages] availableStagesForThisTemplate.length:', availableStagesForThisTemplate.length);
            
            // Obtener referencias a elementos que se mostrarán/ocultarán
            const createStageBtn = document.getElementById('createStageBtn');
            const searchWrapper = document.getElementById('stageSearchWrapper');
            const categoryFilterContainer = document.getElementById('stageCategoryFilterContainer');
            const emptyState = document.getElementById('stagesEmptyState');
            
            // Mostrar/ocultar controles según si hay etapas
            const hasStages = availableStages.length > 0;
            // Ocultar botón de crear etapa de la fila de controles cuando no hay etapas (se mostrará en el empty state)
            if (createStageBtn) createStageBtn.style.display = hasStages ? 'flex' : 'none';
            if (searchWrapper) searchWrapper.style.display = hasStages ? 'flex' : 'none';
            
            // Crear filtro de categorías con componente Input UBITS (solo si hay etapas disponibles)
            try {
                if (categoryFilterContainer && hasStages) {
                    // Limpiar contenedor primero
                    categoryFilterContainer.innerHTML = '';
                    
                    // Estado de categorías seleccionadas (almacenado en el contenedor)
                    if (!categoryFilterContainer.dataset.selectedCategories) {
                        categoryFilterContainer.dataset.selectedCategories = JSON.stringify([]);
                    }
                    
                    // Crear el dropdown de categorías
                    const dropdownHTML = `
                        <div class="category-filter-dropdown">
                            <button type="button" class="category-filter-button ubits-button ubits-button--secondary ubits-button--sm ubits-button--icon-only" id="categoryFilterButton" onclick="toggleCategoryDropdown(event)" title="Filtrar por categorías">
                                <i class="far fa-filter"></i>
                                <span class="category-filter-badge" id="categoryFilterBadge" style="display: none; visibility: hidden;"></span>
                            </button>
                            <div class="category-filter-dropdown-menu" id="categoryFilterMenu">
                                ${STAGE_CATEGORIES.map(cat => `
                                    <label class="category-filter-item" for="category-${cat.id}">
                                        <input type="checkbox" id="category-${cat.id}" value="${cat.id}" onchange="updateCategoryFilter()">
                                        <span class="category-filter-item-label">
                                            <span>${cat.name}</span>
                                        </span>
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    
                    categoryFilterContainer.innerHTML = dropdownHTML;
                } else if (categoryFilterContainer) {
                    categoryFilterContainer.innerHTML = '';
                }
            } catch (e) {
                console.error('Error creando filtro de categorías:', e);
            }
            
            // Renderizar empty state si no hay etapas
            if (availableStages.length === 0) {
                // Ocultar botón de crear etapa de la fila de controles
                if (createStageBtn) createStageBtn.style.display = 'none';
                
                stagesList.innerHTML = `
                    <div class="empty-stages-visual">
                        <div class="empty-icon">
                            <i class="far fa-timeline-arrow"></i>
                        </div>
                        <p class="empty-text">Crea tu primera etapa y empieza a diseñar el recorrido de tu candidato.</p>
                        <button class="ubits-button ubits-button--secondary ubits-button--md" onclick="openCreateStageModal();">
                            <i class="far fa-plus"></i>
                            <span>Crear etapa</span>
                        </button>
                    </div>
                `;
                if (emptyState) emptyState.style.display = 'none';
                return;
            }
            
            // Mostrar botón de crear etapa si hay etapas
            if (createStageBtn) createStageBtn.style.display = 'flex';
            
            // Renderizar empty state si todas las etapas están en uso
            if (availableStagesForThisTemplate.length === 0) {
                stagesList.innerHTML = `
                    <div class="empty-stages-visual">
                        <div class="empty-icon">
                            <i class="far fa-check-circle"></i>
                        </div>
                        <p class="empty-text">Todas las etapas están en uso en esta plantilla</p>
                    </div>
                `;
                if (emptyState) emptyState.style.display = 'none';
                return;
            }
            
            // Renderizar etapas disponibles
            try {
                const stagesHTML = availableStagesForThisTemplate.map(stage => {
                    const category = STAGE_CATEGORIES.find(cat => cat.id === stage.category);
                    return `
                        <div class="stage-item" 
                             draggable="true" 
                             data-stage-id="${stage.id}"
                             data-stage-name="${stage.name}"
                             data-stage-category="${stage.category}">
                            <div class="stage-header">
                                <div class="stage-info">
                                    <div class="stage-name">${stage.name}</div>
                                    <div class="stage-category">Categoría de etapa: ${category ? category.name : stage.category}</div>
                                </div>
                                <div class="stage-menu">
                                    <button class="ubits-button ubits-button--secondary ubits-button--sm ubits-button--icon-only" 
                                            onclick="addStageToFlow('${stage.id}')" 
                                            title="Agregar al flujo">
                                        <i class="far fa-plus"></i>
                                    </button>
                                    <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only" 
                                            onclick="toggleStageTemplateMenu(event, '${stage.id}')" 
                                            title="Opciones">
                                        <i class="far fa-ellipsis-vertical"></i>
                                    </button>
                                    <div class="stage-menu-dropdown" id="stage-template-menu-${stage.id}">
                                        <button class="stage-menu-item" onclick="editStageTemplate('${stage.id}')">
                                            <i class="far fa-pencil"></i>
                                            <span>Editar</span>
                                        </button>
                                        <button class="stage-menu-item stage-menu-item--danger" onclick="deleteStageTemplate('${stage.id}')">
                                            <i class="far fa-trash"></i>
                                            <span>Eliminar</span>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('') + '<div class="library-scroll-spacer"></div>';
                
                stagesList.innerHTML = stagesHTML;
                
                // Agregar event listeners para drag and drop
                if (stagesList) {
                    stagesList.querySelectorAll('.stage-item').forEach(item => {
                        // Remover listeners anteriores si existen
                        const newItem = item.cloneNode(true);
                        item.parentNode.replaceChild(newItem, item);
                    });
                    
                    // Agregar listeners a los nuevos elementos
                    stagesList.querySelectorAll('.stage-item').forEach(item => {
                        item.addEventListener('dragstart', handleStageTemplateDragStart);
                        item.addEventListener('dragend', handleStageTemplateDragEnd);
                    });
                }
                
                // Logs para debuggear el scroll de stages-list
                setTimeout(() => {
                    const stagesListEl = document.getElementById('stagesList');
                    if (stagesListEl) {
                        console.log('🔍 [Stages List Scroll Debug] ============================================');
                        console.log('📦 stagesList.scrollHeight:', stagesListEl.scrollHeight, 'px');
                        console.log('📦 stagesList.clientHeight:', stagesListEl.clientHeight, 'px');
                        console.log('📦 stagesList.scrollTop:', stagesListEl.scrollTop, 'px');
                        console.log('📦 stagesList.maxHeight (computed):', window.getComputedStyle(stagesListEl).maxHeight);
                        console.log('📦 Diferencia (scrollHeight - clientHeight):', stagesListEl.scrollHeight - stagesListEl.clientHeight, 'px');
                        console.log('📦 ¿Tiene scroll?', stagesListEl.scrollHeight > stagesListEl.clientHeight ? '✅ SÍ' : '❌ NO');
                        
                        const lastStage = stagesListEl.querySelector('.stage-item:last-child');
                        const spacer = stagesListEl.querySelector('.library-scroll-spacer');
                        if (lastStage) {
                            const lastStageRect = lastStage.getBoundingClientRect();
                            const containerRect = stagesListEl.getBoundingClientRect();
                            console.log('📦 Último stage-item:');
                            console.log('   - bottom:', lastStageRect.bottom, 'px');
                            console.log('   - container bottom:', containerRect.bottom, 'px');
                            console.log('   - Diferencia:', containerRect.bottom - lastStageRect.bottom, 'px');
                            console.log('   - ¿Está visible?', lastStageRect.bottom <= containerRect.bottom ? '✅ SÍ' : '❌ NO (cortado)');
                        }
                        if (spacer) {
                            const spacerRect = spacer.getBoundingClientRect();
                            const containerRect = stagesListEl.getBoundingClientRect();
                            console.log('📦 Spacer:');
                            console.log('   - bottom:', spacerRect.bottom, 'px');
                            console.log('   - container bottom:', containerRect.bottom, 'px');
                        }
                        console.log('✅ [Stages List Scroll Debug] ============================================');
                    }
                }, 200);
                
                // Re-inicializar el setup de búsqueda después de renderizar
                setTimeout(() => {
                    try {
                        setupStageSearch();
                    } catch (e) {
                        console.error('Error inicializando búsqueda:', e);
                    }
                }, 100);
            } catch (e) {
                console.error('Error renderizando etapas:', e);
            }
        }

        function renderStages() {
            console.log('🔧 [renderStages] Iniciando renderizado de etapas...');
            try {
                renderAvailableStages();
                console.log('✅ [renderStages] Etapas renderizadas correctamente');
            } catch (error) {
                console.error('❌ [renderStages] Error al renderizar etapas:', error);
            }
        }

        // Renderizar agentes en la biblioteca
        window.renderAgents = function() {
            console.log('🚨 [renderAgents] FUNCIÓN LLAMADA - PRIMERA LÍNEA');
            console.log('🚨 [renderAgents] this:', this);
            console.log('🚨 [renderAgents] arguments:', arguments);
            try {
                console.log('🔧 [renderAgents] ========== INICIANDO RENDERIZADO DE AGENTES ==========');
                console.log('🔧 [renderAgents] Verificando variables globales...');
                console.log('🔧 [renderAgents] typeof AGENTS:', typeof AGENTS);
                console.log('🔧 [renderAgents] AGENTS:', AGENTS);
                console.log('🔧 [renderAgents] typeof localTemplateCopy:', typeof localTemplateCopy);
                console.log('🔧 [renderAgents] localTemplateCopy:', localTemplateCopy);
                
                const agentsList = document.getElementById('agentsList');
                console.log('🔧 [renderAgents] agentsList:', agentsList);
                console.log('🔧 [renderAgents] agentsList existe?:', !!agentsList);
                console.log('🔧 [renderAgents] AGENTS disponibles:', AGENTS?.length || 0);
                
                if (!agentsList) {
                    console.error('❌ [renderAgents] agentsList NO ENCONTRADO');
                    return;
                }
                
                if (!localTemplateCopy) {
                    console.error('❌ [renderAgents] localTemplateCopy NO ENCONTRADO');
                    return;
                }
                
                // Filtrar agentes que ya están en uso
                const usedAgentIds = localTemplateCopy.realContent?.stages
                    .filter(s => s.type === 'agent' && s.agentId)
                    .map(s => s.agentId) || [];
                
                console.log('🔧 [renderAgents] Agentes en uso:', usedAgentIds);
                
                const availableAgents = AGENTS.filter(agent => !usedAgentIds.includes(agent.id));
                console.log('🔧 [renderAgents] Agentes disponibles:', availableAgents.length);
                console.log('🔧 [renderAgents] Lista de agentes disponibles:', availableAgents.map(a => a.name));
                
                // Mostrar empty state si todos los agentes están en uso
                if (availableAgents.length === 0) {
                    console.log('⚠️ [renderAgents] Todos los agentes están en uso, mostrando empty state');
                    agentsList.innerHTML = `
                        <div class="empty-stages-visual">
                            <div class="empty-icon">
                                <i class="far fa-check-circle"></i>
                            </div>
                            <p class="empty-text">Todas las etapas con IA están en uso en esta plantilla</p>
                        </div>
                    `;
                    return;
                }
                
                console.log('🔧 [renderAgents] Generando HTML para', availableAgents.length, 'agentes...');
                
                const agentsHTML = availableAgents.map((agent, index) => {
                // Descripción corta para mostrar en la card
                const descriptions = {
                    'cv-analyzer': 'Analiza CV y asigna puntaje',
                    'interview-ia': 'Genera preguntas y analiza respuestas',
                    'psychometric-analyst': 'Evalúa mediante pruebas psicométricas',
                    'background-check': 'Verifica certificado de antecedentes judiciales'
                };
                const agentDescription = descriptions[agent.id] || agent.description;
                
                // Descripción larga para el tooltip del botón de información
                const agentTooltips = {
                    'cv-analyzer': 'Este agente revisa automáticamente los CV, evalúa la experiencia del candidato y verifica que su expectativa salarial esté alineada con el rango de la vacante.',
                    'interview-ia': 'Esta IA realiza entrevistas automáticas por teléfono o entrevista virtual, analiza las respuestas del candidato y asigna un puntaje según sus competencias y forma de responder.',
                    'psychometric-analyst': 'Este agente aplica pruebas psicométricas al candidato y calcula un puntaje que refleja sus capacidades cognitivas y/o rasgos relevantes para el puesto.',
                    'background-check': 'Permite generar y verificar el certificado de antecedentes judiciales del candidato para validar su historial legal de forma segura.'
                };
                const agentTooltip = agentTooltips[agent.id] || agentDescription;
                
                console.log(`🔧 [renderAgents] Agente ${index + 1}/${availableAgents.length}:`, {
                    id: agent.id,
                    name: agent.name,
                    description: agentDescription.substring(0, 50) + '...'
                });
                
                const agentCardHTML = `
                <div class="agent-item" 
                     draggable="true" 
                     data-agent-id="${agent.id}"
                     data-agent-name="${agent.name}"
                     data-agent-icon="${agent.icon}">
                    <div class="agent-header">
                        <div class="agent-title-section">
                            <div class="agent-icon"><i class="far ${agent.icon}"></i></div>
                            <div class="agent-name">${agent.name} (IA)</div>
                        </div>
                        <div class="agent-actions">
                            <button class="ubits-button ubits-button--secondary ubits-button--sm ubits-button--icon-only" 
                                    onclick="addAgentToFlow('${agent.id}')" 
                                    title="Agregar al flujo">
                                <i class="far fa-plus"></i>
                            </button>
                            <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only agent-info-btn"
                                    data-agent-id="${agent.id}"
                                    data-agent-name="${agent.name}"
                                    data-agent-description="${agentTooltip.replace(/"/g, '&quot;')}"
                                    title="Ver más información">
                                <i class="far fa-circle-info"></i>
                            </button>
                        </div>
                    </div>
                    <div class="agent-help">${agentDescription}</div>
                </div>
            `;
                
                // Verificar que el HTML contiene el botón de información
                const hasInfoBtn = agentCardHTML.includes('agent-info-btn');
                console.log(`  ✅ [renderAgents] Agente ${agent.name}: HTML generado, contiene botón info:`, hasInfoBtn);
                if (!hasInfoBtn) {
                    console.error(`  ❌ [renderAgents] ERROR: Agente ${agent.name} NO tiene botón de información en el HTML!`);
                }
                
                    return agentCardHTML;
                }).join('');
                
                console.log('🔧 [renderAgents] HTML completo generado, longitud:', agentsHTML.length);
                console.log('🔧 [renderAgents] HTML contiene "agent-info-btn":', agentsHTML.includes('agent-info-btn'));
                console.log('🔧 [renderAgents] Número de ocurrencias de "agent-info-btn":', (agentsHTML.match(/agent-info-btn/g) || []).length);
                
                // Asignar HTML al contenedor con spacer al final
                agentsList.innerHTML = agentsHTML + '<div class="library-scroll-spacer"></div>';
                console.log('✅ [renderAgents] HTML asignado a agentsList.innerHTML');
                
                // Agregar event listeners para drag and drop
                agentsList.querySelectorAll('.agent-item').forEach(item => {
                    // Remover listeners previos si existen para evitar duplicados
                    item.removeEventListener('dragstart', handleAgentDragStart);
                    item.removeEventListener('dragend', handleAgentDragEnd);
                    // Agregar nuevos listeners
                    item.addEventListener('dragstart', handleAgentDragStart);
                    item.addEventListener('dragend', handleAgentDragEnd);
                });
                console.log('✅ [renderAgents] Event listeners de drag and drop agregados a', agentsList.querySelectorAll('.agent-item').length, 'agentes');
                
                // Verificar inmediatamente después de asignar
                const immediateCheck = agentsList.querySelectorAll('.agent-info-btn');
                console.log('🔍 [renderAgents] Verificación inmediata - Botones encontrados:', immediateCheck.length);
                console.log('🔍 [renderAgents] Verificación inmediata - Botones:', Array.from(immediateCheck).map(btn => ({
                    exists: !!btn,
                    classes: btn.className,
                    dataName: btn.getAttribute('data-agent-name'),
                    innerHTML: btn.innerHTML
                })));
                
                // Verificar también los agent-items
                const agentItems = agentsList.querySelectorAll('.agent-item');
                console.log('🔍 [renderAgents] Total de agent-items encontrados:', agentItems.length);
                agentItems.forEach((item, idx) => {
                    const actionsDiv = item.querySelector('.agent-actions');
                    const infoBtn = item.querySelector('.agent-info-btn');
                    const addBtn = item.querySelector('button[onclick*="addAgentToFlow"]');
                    console.log(`  📦 [renderAgents] Agent-item ${idx + 1}:`, {
                        hasActionsDiv: !!actionsDiv,
                        hasInfoBtn: !!infoBtn,
                        hasAddBtn: !!addBtn,
                        actionsDivChildren: actionsDiv ? actionsDiv.children.length : 0
                    });
                    if (actionsDiv) {
                        console.log(`    🔍 [renderAgents] Agent-item ${idx + 1} - Botones en actionsDiv:`, Array.from(actionsDiv.children).map(child => ({
                            tag: child.tagName,
                            classes: child.className,
                            hasIcon: !!child.querySelector('i')
                        })));
                    }
                });
                
                // Logs para debuggear el scroll de agents-list
                setTimeout(() => {
                    const agentsListEl = document.getElementById('agentsList');
                    if (agentsListEl) {
                        console.log('🔍 [Agents List Scroll Debug] ============================================');
                        console.log('📦 agentsList.scrollHeight:', agentsListEl.scrollHeight, 'px');
                        console.log('📦 agentsList.clientHeight:', agentsListEl.clientHeight, 'px');
                        console.log('📦 agentsList.scrollTop:', agentsListEl.scrollTop, 'px');
                        console.log('📦 agentsList.maxHeight (computed):', window.getComputedStyle(agentsListEl).maxHeight);
                        console.log('📦 Diferencia (scrollHeight - clientHeight):', agentsListEl.scrollHeight - agentsListEl.clientHeight, 'px');
                        console.log('📦 ¿Tiene scroll?', agentsListEl.scrollHeight > agentsListEl.clientHeight ? '✅ SÍ' : '❌ NO');
                        
                        const lastAgent = agentsListEl.querySelector('.agent-item:last-child');
                        const spacer = agentsListEl.querySelector('.library-scroll-spacer');
                        if (lastAgent) {
                            const lastAgentRect = lastAgent.getBoundingClientRect();
                            const containerRect = agentsListEl.getBoundingClientRect();
                            console.log('📦 Último agent-item:');
                            console.log('   - bottom:', lastAgentRect.bottom, 'px');
                            console.log('   - container bottom:', containerRect.bottom, 'px');
                            console.log('   - Diferencia:', containerRect.bottom - lastAgentRect.bottom, 'px');
                            console.log('   - ¿Está visible?', lastAgentRect.bottom <= containerRect.bottom ? '✅ SÍ' : '❌ NO (cortado)');
                        }
                        if (spacer) {
                            const spacerRect = spacer.getBoundingClientRect();
                            const containerRect = agentsListEl.getBoundingClientRect();
                            console.log('📦 Spacer:');
                            console.log('   - bottom:', spacerRect.bottom, 'px');
                            console.log('   - container bottom:', containerRect.bottom, 'px');
                        }
                        console.log('✅ [Agents List Scroll Debug] ============================================');
                    }
                }, 200);
                
                // Agregar event listeners para tooltips de información de agentes
                setTimeout(() => {
                    console.log('🔍 [renderAgents] ========== AGREGANDO EVENT LISTENERS ==========');
                    const infoButtons = agentsList.querySelectorAll('.agent-info-btn');
                    console.log('🔍 [renderAgents] Botones de información encontrados después de timeout:', infoButtons.length);
                    
                    if (infoButtons.length === 0) {
                        console.error('❌ [renderAgents] ERROR: No se encontraron botones de información después del timeout!');
                        console.error('❌ [renderAgents] agentsList.innerHTML length:', agentsList.innerHTML.length);
                        console.error('❌ [renderAgents] agentsList.innerHTML contiene "agent-info-btn":', agentsList.innerHTML.includes('agent-info-btn'));
                        
                        // Buscar todos los botones en agent-actions
                        const allButtons = agentsList.querySelectorAll('.agent-actions button');
                        console.error('❌ [renderAgents] Total de botones en agent-actions:', allButtons.length);
                        allButtons.forEach((btn, idx) => {
                            console.error(`  🔍 Botón ${idx + 1}:`, {
                                classes: btn.className,
                                hasAgentInfoBtn: btn.classList.contains('agent-info-btn'),
                                innerHTML: btn.innerHTML
                            });
                        });
                    } else {
                        infoButtons.forEach((btn, idx) => {
                            console.log(`  ✅ [renderAgents] Botón ${idx + 1}:`, {
                                exists: !!btn,
                                classes: btn.className,
                                dataName: btn.getAttribute('data-agent-name'),
                                innerHTML: btn.innerHTML,
                                computedDisplay: window.getComputedStyle(btn).display,
                                computedVisibility: window.getComputedStyle(btn).visibility,
                                computedOpacity: window.getComputedStyle(btn).opacity,
                                computedWidth: window.getComputedStyle(btn).width,
                                computedHeight: window.getComputedStyle(btn).height
                            });
                            btn.addEventListener('mouseenter', handleAgentInfoHover);
                            btn.addEventListener('mouseleave', handleAgentInfoLeave);
                            console.log(`  ✅ [renderAgents] Event listeners agregados al botón ${idx + 1}`);
                        });
                    }
                    console.log('✅ [renderAgents] ========== FIN DE AGREGADO DE EVENT LISTENERS ==========');
                }, 100);
                
                console.log('✅ [renderAgents] ========== FIN DE RENDERIZADO DE AGENTES ==========');
            } catch (e) {
                console.error('❌ [renderAgents] ERROR CRÍTICO:', e);
                console.error('❌ [renderAgents] Stack trace:', e.stack);
                console.error('❌ [renderAgents] Mensaje:', e.message);
            }
        }

        // Agregar agente al flujo
        window.addAgentToFlow = function(agentId) {
            if (!localTemplateCopy || !isEditMode) return;
            
            const agentData = AGENTS.find(a => a.id === agentId);
            if (!agentData) return;
            
            const newAgentStage = {
                id: 'agent-' + Date.now(),
                type: 'agent',
                agentId: agentId,
                config: {},
                expanded: false
            };
            
            // Inicializar configuración por defecto
            if (agentData.config) {
                Object.entries(agentData.config).forEach(([key, field]) => {
                    newAgentStage.config[key] = field.default;
                });
            }
            
            // Inicializar tests para psicométrico
            if (agentId === 'psychometric-analyst') {
                newAgentStage.config.tests = [];
            }
            
            localTemplateCopy.realContent.stages.push(newAgentStage);
            renderTemplateFlow(localTemplateCopy);
            renderAgents();
            
            // Si es analista psicométrico, abrir drawer automáticamente en modo creación
            if (agentId === 'psychometric-analyst') {
                setTimeout(() => {
                    if (typeof window.openPsychometricTestsDrawer === 'function') {
                        // Abrir drawer y establecer directamente en modo creación
                        if (!localTemplateCopy || !isEditMode) return;
                        currentPsychometricStageId = newAgentStage.id;
                        editingTestId = null;
                        currentDrawerView = 'create'; // Establecer directamente en modo creación
                        
                        const drawer = document.getElementById('psychometricTestsDrawer');
                        if (drawer) {
                            drawer.classList.add('active');
                            renderPsychometricTestsView();
                        }
                    }
                }, 300);
            }
            
            // Si es entrevista Serena, abrir drawer de configuración automáticamente
            if (agentId === 'interview-ia') {
                setTimeout(() => {
                    if (typeof window.openSerenaConfigDrawer === 'function') {
                        window.openSerenaConfigDrawer(newAgentStage.id);
                    }
                }, 300);
            }
        };

        // Cambiar tab en la biblioteca
        window.switchTab = function(tabName) {
            console.log('🔧 [switchTab] ========== CAMBIANDO TAB ==========');
            console.log('🔧 [switchTab] Tab seleccionado:', tabName);
            
            const tabs = document.querySelectorAll('#agents-sidebar .tab-button');
            const contents = document.querySelectorAll('#agents-sidebar .tab-content');
            
            console.log('🔧 [switchTab] Tabs encontrados:', tabs.length);
            console.log('🔧 [switchTab] Contents encontrados:', contents.length);
            
            tabs.forEach(tab => {
                if (tab.dataset.tab === tabName) {
                    tab.classList.add('active');
                    console.log('✅ [switchTab] Tab activado:', tab.dataset.tab);
                } else {
                    tab.classList.remove('active');
                }
            });
            
            contents.forEach(content => {
                if (content.id === `${tabName}-tab`) {
                    content.classList.add('active');
                    console.log('✅ [switchTab] Content activado:', content.id);
                } else {
                    content.classList.remove('active');
                }
            });
            
            // Renderizar contenido según el tab seleccionado
            if (tabName === 'stages') {
                console.log('🔧 [switchTab] Llamando a renderStages()...');
                try {
                    renderStages();
                } catch (e) {
                    console.error('❌ [switchTab] Error al llamar renderStages():', e);
                }
            } else if (tabName === 'agents') {
                console.log('🔧 [switchTab] Llamando a renderAgents()...');
                console.log('🔧 [switchTab] typeof renderAgents:', typeof renderAgents);
                console.log('🔧 [switchTab] renderAgents es función?:', typeof renderAgents === 'function');
                try {
                    if (typeof renderAgents === 'function') {
                        console.log('🔧 [switchTab] Ejecutando renderAgents()...');
                        const result = renderAgents();
                        console.log('🔧 [switchTab] renderAgents() retornó:', result);
                        console.log('🔧 [switchTab] renderAgents() ejecutado, verificando si hay logs...');
                    } else {
                        console.error('❌ [switchTab] renderAgents NO es una función!', renderAgents);
                    }
                } catch (e) {
                    console.error('❌ [switchTab] Error al llamar renderAgents():', e);
                    console.error('❌ [switchTab] Stack trace:', e.stack);
                    console.error('❌ [switchTab] Error name:', e.name);
                    console.error('❌ [switchTab] Error message:', e.message);
                }
            } else {
                console.warn('⚠️ [switchTab] Tab desconocido:', tabName);
            }
            
            console.log('✅ [switchTab] ========== FIN DE CAMBIO DE TAB ==========');
        };

        // Configurar búsqueda de etapas
        function setupStageSearch() {
            try {
                const searchInput = document.getElementById('stageSearch');
                const clearButton = document.getElementById('clearStageSearch');
                const stagesList = document.getElementById('stagesList');
                const emptyState = document.getElementById('stagesEmptyState');
                const emptyStateText = document.getElementById('stagesEmptyStateText');
                
                if (!searchInput || !clearButton || !stagesList) {
                    return;
                }
                
                // Asegurar que el empty state esté oculto al inicio
                if (emptyState) {
                    emptyState.style.display = 'none';
                }
                
                // Función para aplicar filtros (búsqueda + categoría) y mostrar empty state
                function applyFilters() {
                    const searchTerm = searchInput.value.toLowerCase().trim();
                    
                    // Obtener categorías seleccionadas del dropdown
                    let selectedCategories = [];
                    const categoryFilterContainer = document.getElementById('stageCategoryFilterContainer');
                    if (categoryFilterContainer && categoryFilterContainer.dataset.selectedCategories) {
                        try {
                            selectedCategories = JSON.parse(categoryFilterContainer.dataset.selectedCategories);
                        } catch (e) {
                            selectedCategories = [];
                        }
                    }
                    
                    const stageItems = stagesList.querySelectorAll('.stage-item');
                    let visibleCount = 0;
                    
                    // Mostrar/ocultar botón de limpiar
                    clearButton.style.display = searchTerm ? 'block' : 'none';
                    
                    // Filtrar etapas
                    stageItems.forEach(item => {
                        const stageName = item.getAttribute('data-stage-name')?.toLowerCase() || '';
                        const stageCategory = item.getAttribute('data-stage-category') || '';
                        
                        // Filtro por búsqueda
                        const matchesSearch = !searchTerm || 
                            stageName.includes(searchTerm) || 
                            stageCategory.toLowerCase().includes(searchTerm);
                        
                        // Filtro por categoría (múltiple)
                        const matchesCategory = selectedCategories.length === 0 || selectedCategories.includes(stageCategory);
                        
                        // Mostrar si cumple ambos filtros
                        if (matchesSearch && matchesCategory) {
                            item.style.display = 'flex';
                            visibleCount++;
                        } else {
                            item.style.display = 'none';
                        }
                    });
                    
                    // Mostrar/ocultar empty state SOLO cuando hay búsqueda/filtro activo y no hay resultados
                    if (emptyState && emptyStateText) {
                        if ((searchTerm || selectedCategories.length > 0) && visibleCount === 0) {
                            emptyState.style.display = 'flex';
                            emptyStateText.textContent = 'No se encontraron etapas';
                        } else {
                            emptyState.style.display = 'none';
                        }
                    }
                }
                
                // Event listeners
                searchInput.addEventListener('input', applyFilters);
                clearButton.addEventListener('click', () => {
                    searchInput.value = '';
                    clearButton.style.display = 'none';
                    applyFilters();
                });
            } catch (e) {
                console.error('Error configurando búsqueda de etapas:', e);
            }
        }

        // Toggle dropdown de categorías
        window.toggleCategoryDropdown = function(event) {
            event.stopPropagation();
            const menu = document.getElementById('categoryFilterMenu');
            if (!menu) return;
            
            const isShowing = menu.classList.contains('show');
            
            // Cerrar todos los dropdowns primero
            document.querySelectorAll('.category-filter-dropdown-menu').forEach(m => {
                m.classList.remove('show');
            });
            
            if (!isShowing) {
                menu.classList.add('show');
                // Posicionar el dropdown
                const button = event.target.closest('.category-filter-button');
                if (button) {
                    const rect = button.getBoundingClientRect();
                    menu.style.top = `${rect.bottom + 4}px`;
                    menu.style.left = `${rect.left}px`;
                }
            }
        };

        // Actualizar filtro de categorías
        window.updateCategoryFilter = function() {
            const categoryFilterContainer = document.getElementById('stageCategoryFilterContainer');
            if (!categoryFilterContainer) return;
            
            // Obtener todas las categorías seleccionadas
            const checkboxes = categoryFilterContainer.querySelectorAll('input[type="checkbox"]:checked');
            const selectedCategories = Array.from(checkboxes).map(cb => cb.value);
            
            // Guardar en el dataset
            categoryFilterContainer.dataset.selectedCategories = JSON.stringify(selectedCategories);
            
            // Actualizar badge y estado del botón
            const badge = document.getElementById('categoryFilterBadge');
            const button = document.getElementById('categoryFilterButton');
            
            if (badge && button) {
                console.log('🔍 [updateCategoryFilter] Badge encontrado:', badge);
                console.log('🔍 [updateCategoryFilter] Button encontrado:', button);
                console.log('🔍 [updateCategoryFilter] Categorías seleccionadas:', selectedCategories.length);
                
                if (selectedCategories.length > 0) {
                    const count = selectedCategories.length;
                    badge.textContent = count.toString();
                    badge.style.display = 'inline-flex';
                    badge.style.color = '#ffffff';
                    badge.style.overflow = 'visible';
                    badge.style.visibility = 'visible';
                    
                    // Ajustar estilo para números de dos dígitos
                    if (count > 9) {
                        console.log('🔍 [updateCategoryFilter] Número de dos dígitos:', count);
                        badge.classList.add('badge-double-digit');
                        badge.style.minWidth = '20px';
                        badge.style.width = 'auto';
                        badge.style.padding = '0 5px';
                        badge.style.borderRadius = '9px';
                    } else {
                        console.log('🔍 [updateCategoryFilter] Número de un dígito:', count);
                        badge.classList.remove('badge-double-digit');
                        badge.style.minWidth = '18px';
                        badge.style.width = '18px';
                        badge.style.padding = '0';
                        badge.style.borderRadius = '50%';
                    }
                    
                    // Forzar color blanco
                    badge.style.color = '#ffffff';
                    badge.setAttribute('style', badge.getAttribute('style') + ' color: #ffffff !important;');
                    const badgeText = badge.querySelector('*');
                    if (badgeText) {
                        badgeText.style.color = '#ffffff';
                    }
                    
                    console.log('🔍 [updateCategoryFilter] Estilos aplicados:', {
                        display: badge.style.display,
                        color: badge.style.color,
                        minWidth: badge.style.minWidth,
                        padding: badge.style.padding,
                        borderRadius: badge.style.borderRadius,
                        textContent: badge.textContent,
                        visibility: badge.style.visibility
                    });
                    
                    button.classList.add('ubits-button--active');
                } else {
                    // Ocultar completamente el badge cuando no hay filtros
                    badge.style.display = 'none';
                    badge.style.visibility = 'hidden';
                    badge.textContent = '';
                    badge.classList.remove('badge-double-digit');
                    button.classList.remove('ubits-button--active');
                    console.log('🔍 [updateCategoryFilter] Badge ocultado - no hay filtros');
                }
            } else {
                console.error('🔍 [updateCategoryFilter] Badge o button no encontrado');
            }
            
            // Aplicar filtros
            const searchInput = document.getElementById('stageSearch');
            if (searchInput) {
                const event = new Event('input');
                searchInput.dispatchEvent(event);
            }
        };

        // Cerrar dropdown al hacer clic fuera
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.category-filter-dropdown')) {
                document.querySelectorAll('.category-filter-dropdown-menu').forEach(menu => {
                    menu.classList.remove('show');
                });
            }
        });

        // Agregar etapa al flujo
        window.addStageToFlow = function(stageId) {
            if (!localTemplateCopy || !isEditMode) return;
            
            const stageTemplate = availableStages.find(s => s.id === stageId);
            if (!stageTemplate) return;
            
            // Crear nueva etapa basada en el template
            const newStage = {
                id: `stage-${Date.now()}`,
                type: 'custom',
                name: stageTemplate.name,
                category: stageTemplate.category,
                description: stageTemplate.description || '',
                templateId: stageTemplate.id
            };
            
            localTemplateCopy.realContent.stages.push(newStage);
            renderTemplateFlow(localTemplateCopy);
            
            // Re-renderizar la lista de etapas para ocultar la que se agregó
            renderAvailableStages();
            
            if (typeof showToast === 'function') {
                showToast('success', 'Etapa agregada al flujo');
            }
        };

        // Generar ID único para etapa
        function generateStageId() {
            return 'stage-' + Date.now() + '-' + Math.random().toString(36).substring(2, 11);
        }

        // Guardar etapas en localStorage
        function saveAvailableStages() {
            console.log('💾 [saveAvailableStages] Guardando etapas:', availableStages.length);
            localStorage.setItem('availableStages', JSON.stringify(availableStages));
            
            // Verificar que se guardó correctamente
            const stored = localStorage.getItem('availableStages');
            if (stored) {
                const parsed = JSON.parse(stored);
                if (parsed.length !== availableStages.length) {
                    console.error('❌ [saveAvailableStages] ERROR: Las etapas no se guardaron correctamente');
                    console.error('   Esperado:', availableStages.length, 'Guardado:', parsed.length);
                } else {
                    console.log('✅ [saveAvailableStages] Etapas guardadas correctamente');
                }
            }
        }

        // Crear etapa template
        function createStageTemplate(formData) {
            const { stageName, stageCategory, stageDescription } = formData;
            
            // Validar que el nombre no esté vacío
            if (!stageName || !stageName.trim()) {
                if (typeof showToast === 'function') {
                    showToast('error', 'El nombre de la etapa es obligatorio');
                }
                return;
            }
            
            // Validar que el nombre no esté duplicado
            const existingStage = availableStages.find(stage => 
                stage.name.toLowerCase() === stageName.toLowerCase()
            );
            
            if (existingStage) {
                if (typeof showToast === 'function') {
                    showToast('error', 'Ya existe una etapa con ese nombre');
                }
                return;
            }
            
            // Crear nueva etapa personalizada (tipo 'custom')
            const newStage = {
                id: generateStageId(),
                name: stageName.trim(),
                category: stageCategory,
                type: 'custom',
                description: stageDescription?.trim() || '',
                createdAt: new Date().toISOString()
            };
            
            // Agregar a la lista de etapas disponibles
            availableStages.push(newStage);
            
            // Guardar en localStorage
            saveAvailableStages();
            
            // Re-renderizar la lista de etapas
            renderAvailableStages();
            
            // Mostrar toast de éxito
            if (typeof showToast === 'function') {
                showToast('success', `Etapa "${stageName}" creada exitosamente`);
            }
        }

        // Abrir modal de crear etapa
        window.openCreateStageModal = function() {
            // Establecer callback ANTES de abrir el modal
            window.modalFormCallback = function(formData) {
                try {
                    createStageTemplate(formData);
                } catch (error) {
                    console.error('Error al crear etapa:', error);
                    if (typeof showToast === 'function') {
                        showToast('error', 'Error al crear la etapa: ' + error.message);
                    }
                }
            };
            
            if (typeof showFormModal === 'function') {
                showFormModal({
                    title: 'Crear nueva etapa',
                    message: 'Las etapas personalizadas son procesos manuales que puedes usar para organizar tu flujo de selección',
                    fields: [
                        {
                            id: 'stageName',
                            label: 'Nombre de la etapa',
                            type: 'text',
                            placeholder: 'Ej: Entrevista técnica',
                            required: true,
                            maxLength: 50,
                            size: 'md'
                        },
                        {
                            id: 'stageCategory',
                            label: 'Categoría',
                            type: 'select',
                            required: true,
                            size: 'md',
                            placeholder: 'Selecciona una categoría',
                            selectOptions: STAGE_CATEGORIES.map(cat => ({
                                value: cat.id,
                                text: cat.name
                            }))
                        },
                        {
                            id: 'stageDescription',
                            label: 'Descripción (opcional)',
                            type: 'textarea',
                            placeholder: 'Describe brevemente esta etapa y qué implica...',
                            required: false,
                            maxLength: 500,
                            size: 'md'
                        }
                    ],
                    submitText: 'Crear etapa',
                    cancelText: 'Cancelar',
                    onSubmit: function(formData) {
                        if (window.modalFormCallback) {
                            window.modalFormCallback(formData);
                        }
                    },
                    onCancel: function() {
                        console.log('Modal cancelado');
                    }
                });
            } else {
                console.error('showFormModal no está disponible');
                if (typeof showToast === 'function') {
                    showToast('error', 'Error: El modal no está disponible');
                }
            }
        };

        // Editar etapa template (redirigir al editor)
        window.editStageTemplate = function(stageId) {
            if (selectedTemplate) {
                window.location.href = `editor-plantillas.html?id=${selectedTemplate.id}`;
            } else {
                window.location.href = 'editor-plantillas.html';
            }
        };

        // Eliminar etapa template
        window.deleteStageTemplate = function(stageId) {
            const stage = availableStages.find(s => s.id === stageId);
            if (!stage) {
                console.error('❌ [deleteStageTemplate] Etapa no encontrada:', stageId);
                if (typeof showToast === 'function') {
                    showToast('error', 'Etapa no encontrada');
                }
                return;
            }
            
            if (typeof showConfirmModal === 'function') {
                showConfirmModal({
                    title: 'Eliminar etapa',
                    message: `¿Estás seguro de que quieres eliminar la etapa "${stage.name}"? Esta acción no se puede deshacer.`,
                    confirmText: 'Eliminar',
                    cancelText: 'Cancelar',
                    variant: 'error',
                    onConfirm: () => {
                        console.log('🗑️ [deleteStageTemplate] Eliminando etapa:', stageId);
                        console.log('🔍 [deleteStageTemplate] availableStages antes:', availableStages.length);
                        
                        // Filtrar la etapa eliminada
                        availableStages = availableStages.filter(s => s.id !== stageId);
                        
                        console.log('🔍 [deleteStageTemplate] availableStages después:', availableStages.length);
                        
                        // Guardar usando la función saveAvailableStages para mantener consistencia
                        saveAvailableStages();
                        
                        // Verificar que se guardó correctamente
                        const stored = localStorage.getItem('availableStages');
                        if (stored) {
                            const parsed = JSON.parse(stored);
                            console.log('✅ [deleteStageTemplate] Verificación - etapas guardadas en localStorage:', parsed.length);
                            if (parsed.length !== availableStages.length) {
                                console.error('❌ [deleteStageTemplate] INCONSISTENCIA: Las etapas no se guardaron correctamente');
                                // Forzar guardado de nuevo
                                localStorage.setItem('availableStages', JSON.stringify(availableStages));
                            }
                        }
                        
                        // Re-renderizar SIN recargar desde localStorage
                        renderAvailableStages();
                        
                        if (typeof showToast === 'function') {
                            showToast('success', `Etapa "${stage.name}" eliminada correctamente`);
                        }
                    }
                });
            } else {
                if (confirm(`¿Estás seguro de que quieres eliminar la etapa "${stage.name}"?`)) {
                    console.log('🗑️ [deleteStageTemplate] Eliminando etapa (sin modal):', stageId);
                    availableStages = availableStages.filter(s => s.id !== stageId);
                    saveAvailableStages();
                    renderAvailableStages();
                }
            }
        };

        // Toggle menú de opciones de etapa
        window.toggleStageTemplateMenu = function(event, stageId) {
            event.stopPropagation();
            const menu = document.getElementById(`stage-template-menu-${stageId}`);
            if (!menu) return;
            
            // Cerrar todos los menús primero
            document.querySelectorAll('.stage-menu-dropdown').forEach(m => {
                if (m.id !== `stage-template-menu-${stageId}`) {
                    m.classList.remove('show');
                }
            });
            
            menu.classList.toggle('show');
        };

        // Cerrar menús al hacer clic fuera
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.stage-menu')) {
                document.querySelectorAll('.stage-menu-dropdown').forEach(menu => {
                    menu.classList.remove('show');
                });
            }
        });

        // Variables globales para drawers
        let currentPsychometricStageId = null;
        let editingTestId = null;
        let currentDrawerView = 'list'; // 'list', 'create', 'edit'
        let currentSerenaStageId = null;

        // Abrir drawer de pruebas psicométricas
        window.openPsychometricTestsDrawer = function(stageId) {
            if (!isEditMode || !localTemplateCopy) return;
            currentPsychometricStageId = stageId;
            editingTestId = null;
            currentDrawerView = 'list';
            
            const drawer = document.getElementById('psychometricTestsDrawer');
            if (drawer) {
                drawer.classList.add('active');
                renderPsychometricTestsView();
            }
        };

        // Mostrar vista de creación de prueba
        window.showCreateTestView = function() {
            if (!currentPsychometricStageId || !localTemplateCopy) return;
            currentDrawerView = 'create';
            editingTestId = null;
            renderPsychometricTestsView();
            
            // Asegurar que el drawer siga abierto
            const drawer = document.getElementById('psychometricTestsDrawer');
            if (drawer) {
                drawer.classList.add('active');
            }
        };

        // Cerrar drawer de pruebas psicométricas
        function closePsychometricTestsDrawer() {
            const drawer = document.getElementById('psychometricTestsDrawer');
            if (drawer) {
                drawer.classList.remove('active');
            }
            currentPsychometricStageId = null;
            editingTestId = null;
            currentDrawerView = 'list';
        }

        // Manejar click en overlay
        window.handleDrawerOverlayClick = function(event) {
            if (event.target.closest('.drawer-content')) {
                event.stopPropagation();
                event.preventDefault();
                return false;
            }
            closePsychometricTestsDrawer();
        };

        // Manejar botón cerrar
        window.handleDrawerCloseButton = function(event) {
            event.stopPropagation();
            event.preventDefault();
            
            if (currentDrawerView === 'list') {
                closePsychometricTestsDrawer();
            } else {
                showListView(event);
            }
            
            return false;
        };

        // Mostrar vista de lista
        window.showListView = function(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            currentDrawerView = 'list';
            editingTestId = null;
            renderPsychometricTestsView();
            
            const drawer = document.getElementById('psychometricTestsDrawer');
            if (drawer) {
                drawer.classList.add('active');
            }
            
            return false;
        };

        // Renderizar vista de pruebas psicométricas
        function renderPsychometricTestsView() {
            const listContainer = document.getElementById('psychometricTestsList');
            const drawerTitle = document.getElementById('drawerTitle');
            const drawerFooterActions = document.getElementById('drawerFooterActions');
            
            if (!listContainer || !currentPsychometricStageId || !localTemplateCopy) return;
            
            const stage = localTemplateCopy.realContent.stages.find(s => s.id === currentPsychometricStageId);
            if (!stage) return;
            
            const agentData = AGENTS.find(a => a.id === 'psychometric-analyst');
            if (!agentData) return;
            
            const tests = stage.config?.tests || [];
            
            listContainer.innerHTML = '';
            
            const drawerFooter = document.querySelector('#psychometricTestsDrawer .drawer-footer');
            
            if (currentDrawerView === 'create') {
                // Vista de creación
                console.log('🟢 Renderizando vista de CREACIÓN de prueba psicométrica');
                if (drawerTitle) drawerTitle.textContent = 'Nueva prueba psicotécnica';
                
                // Generar testId único para esta creación
                const newTestId = 'test-' + Date.now();
                console.log('  🆔 TestId generado:', newTestId);
                
                // Verificar que renderTestForm existe
                if (typeof renderTestForm !== 'function') {
                    console.error('❌ renderTestForm no está definida');
                    return;
                }
                
                // Renderizar formulario
                const formHTML = renderTestForm(null, newTestId);
                console.log('  📝 Form HTML generado:', formHTML ? 'Sí' : 'No');
                listContainer.innerHTML = formHTML;
                
                // Asegurar que el footer esté visible en creación
                if (drawerFooter) {
                    drawerFooter.style.display = 'flex';
                    console.log('  ✅ Footer visible');
                } else {
                    console.error('❌ drawerFooter no encontrado');
                }
                
                // Renderizar botones en el footer
                if (drawerFooterActions) {
                    drawerFooterActions.innerHTML = `
                        <button class="ubits-button ubits-button--secondary ubits-button--md" onclick="showListView(event)">
                            <span>Cancelar</span>
                        </button>
                        <button class="ubits-button ubits-button--primary ubits-button--md" onclick="savePsychometricTest('${newTestId}')">
                            <i class="far fa-check"></i>
                            <span>Guardar</span>
                        </button>
                    `;
                    console.log('  ✅ Botones del footer renderizados');
                } else {
                    console.error('❌ drawerFooterActions no encontrado');
                }
                
                // Inicializar inputs del formulario
                setTimeout(() => {
                    console.log('  🔧 Inicializando inputs del formulario...');
                    console.log('  📋 Verificando elementos del DOM...');
                    const form = document.querySelector('.test-form');
                    const typeContainer = document.getElementById(`test-form-type-${newTestId}`);
                    const languageContainer = document.getElementById(`test-form-language-${newTestId}`);
                    const minScoreContainer = document.getElementById(`test-form-minscore-${newTestId}`);
                    console.log('  📦 Elementos encontrados:', {
                        form: !!form,
                        typeContainer: !!typeContainer,
                        languageContainer: !!languageContainer,
                        minScoreContainer: !!minScoreContainer,
                        createInput: typeof createInput
                    });
                    
                    if (typeof initializeTestFormInputs === 'function') {
                        initializeTestFormInputs(newTestId);
                        console.log('  ✅ Inputs inicializados');
                    } else {
                        console.error('❌ initializeTestFormInputs no está definida');
                    }
                    
                    // Agregar event listeners para tooltips de información
                    const drawer = document.getElementById('psychometricTestsDrawer');
                    if (drawer) {
                        drawer.querySelectorAll('.test-form-info-btn').forEach(btn => {
                            // Remover listeners previos si existen para evitar duplicados
                            btn.removeEventListener('mouseenter', handleConfigInfoHover);
                            btn.removeEventListener('mouseleave', handleConfigInfoLeave);
                            // Agregar nuevos listeners
                            btn.addEventListener('mouseenter', handleConfigInfoHover);
                            btn.addEventListener('mouseleave', handleConfigInfoLeave);
                        });
                        console.log('  ✅ Event listeners de tooltips agregados');
                    }
                }, 500);
            } else if (currentDrawerView === 'edit' && editingTestId !== null) {
                // Vista de edición
                console.log('🟢 Renderizando vista de EDICIÓN de prueba psicométrica', { editingTestId });
                if (drawerTitle) drawerTitle.textContent = 'Editar prueba psicotécnica';
                
                const testToEdit = tests.find(t => t.id === editingTestId);
                if (testToEdit) {
                    console.log('  ✅ Prueba encontrada para editar:', testToEdit);
                    
                    // Renderizar formulario con los datos de la prueba
                    const formHTML = renderTestForm(testToEdit, testToEdit.id);
                    listContainer.innerHTML = formHTML;
                    
                    // Asegurar que el footer esté visible en edición
                    if (drawerFooter) {
                        drawerFooter.style.display = 'flex';
                    }
                    
                    // Renderizar botones en el footer
                    if (drawerFooterActions) {
                        drawerFooterActions.innerHTML = `
                            <button class="ubits-button ubits-button--secondary ubits-button--md" onclick="showListView(event)">
                                <span>Cancelar</span>
                            </button>
                            <button class="ubits-button ubits-button--primary ubits-button--md" onclick="savePsychometricTest('${testToEdit.id}')">
                                <i class="far fa-check"></i>
                                <span>Guardar</span>
                            </button>
                        `;
                    }
                    
                    // Inicializar inputs del formulario con los valores de la prueba
                    setTimeout(() => {
                        initializeTestFormInputs(testToEdit.id);
                        
                        // Agregar event listeners para tooltips de información
                        const drawer = document.getElementById('psychometricTestsDrawer');
                        if (drawer) {
                            drawer.querySelectorAll('.test-form-info-btn').forEach(btn => {
                                // Remover listeners previos si existen para evitar duplicados
                                btn.removeEventListener('mouseenter', handleConfigInfoHover);
                                btn.removeEventListener('mouseleave', handleConfigInfoLeave);
                                // Agregar nuevos listeners
                                btn.addEventListener('mouseenter', handleConfigInfoHover);
                                btn.addEventListener('mouseleave', handleConfigInfoLeave);
                            });
                        }
                    }, 300);
                } else {
                    console.log('  ⚠️ Prueba no encontrada, volviendo a lista');
                    // Si no se encuentra la prueba, volver a lista
                    currentDrawerView = 'list';
                    editingTestId = null;
                    renderPsychometricTestsView();
                }
            } else if (currentDrawerView === 'list') {
                if (drawerTitle) drawerTitle.textContent = 'Pruebas psicotécnicas';
                
                const hasTests = tests && tests.length > 0;
                
                if (drawerFooterActions) {
                    if (hasTests) {
                        drawerFooterActions.innerHTML = `
                            <button class="ubits-button ubits-button--primary ubits-button--md" onclick="addPsychometricTest()">
                                <i class="far fa-plus"></i>
                                <span>Agregar prueba</span>
                            </button>
                        `;
                        if (drawerFooter) drawerFooter.style.display = 'flex';
                    } else {
                        drawerFooterActions.innerHTML = '';
                        if (drawerFooter) drawerFooter.style.display = 'none';
                    }
                }
                
                renderTestsList(tests, agentData);
            }
        }

        // Renderizar lista de pruebas
        function renderTestsList(tests, agentData) {
            const listContainer = document.getElementById('psychometricTestsList');
            if (!listContainer) return;
            
            if (tests.length === 0) {
                listContainer.innerHTML = `
                    <div class="empty-stages-visual">
                        <div class="empty-icon">
                            <i class="far fa-list"></i>
                        </div>
                        <p class="empty-text">No hay pruebas configuradas</p>
                        <button class="ubits-button ubits-button--primary ubits-button--md" onclick="addPsychometricTest()">
                            <i class="far fa-plus"></i>
                            <span>Agregar primera prueba</span>
                        </button>
                    </div>
                `;
                return;
            }
            
            listContainer.innerHTML = tests.map((test, index) => {
                const testType = agentData.testTypes?.find(t => t.value === test.type);
                const testTypeText = testType ? testType.text : test.type;
                const minScore = test.minScore ?? 0;
                
                return `
                    <div class="test-item">
                        <div class="test-item-header">
                            <div class="test-item-info">
                                <div class="test-item-title">${testTypeText}</div>
                                <div class="test-item-subtitle">Prueba ${index + 1} de ${tests.length}</div>
                            </div>
                            <div class="test-item-actions">
                                <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only" onclick="editPsychometricTest('${test.id}')" title="Editar">
                                    <i class="far fa-edit"></i>
                                </button>
                                <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only" onclick="deletePsychometricTest('${test.id}')" title="Eliminar" style="color: var(--ubits-feedback-accent-error);">
                                    <i class="far fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="test-item-fields">
                            <div class="test-item-field">
                                <label>Puntaje mínimo</label>
                                <div class="test-item-field-value">${minScore} pts</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Agregar prueba psicométrica (mostrar vista de creación)
        window.addPsychometricTest = function() {
            if (!currentPsychometricStageId || !localTemplateCopy) return;
            currentDrawerView = 'create';
            editingTestId = null;
            renderPsychometricTestsView();
            
            const drawer = document.getElementById('psychometricTestsDrawer');
            if (drawer) {
                drawer.classList.add('active');
            }
        };

        // Editar prueba psicométrica
        window.editPsychometricTest = function(testId) {
            if (!currentPsychometricStageId || !localTemplateCopy) return;
            
            const stage = localTemplateCopy.realContent.stages.find(s => s.id === currentPsychometricStageId);
            if (!stage || !stage.config || !stage.config.tests) return;
            
            const test = stage.config.tests.find(t => t.id === testId);
            if (!test) return;
            
            // Establecer modo edición
            editingTestId = testId;
            currentDrawerView = 'edit';
            
            // Re-renderizar vista
            renderPsychometricTestsView();
            
            const drawer = document.getElementById('psychometricTestsDrawer');
            if (drawer) {
                drawer.classList.add('active');
            }
        };

        // Mostrar vista de edición
        window.showEditTestView = function(testId) {
            if (!currentPsychometricStageId || !localTemplateCopy) return;
            
            const stage = localTemplateCopy.realContent.stages.find(s => s.id === currentPsychometricStageId);
            if (!stage || !stage.config || !stage.config.tests) return;
            
            const test = stage.config.tests.find(t => t.id === testId);
            if (!test) return;
            
            editingTestId = testId;
            currentDrawerView = 'edit';
            renderPsychometricTestsView();
            
            const drawer = document.getElementById('psychometricTestsDrawer');
            if (drawer) {
                drawer.classList.add('active');
            }
        };

        // Eliminar prueba psicométrica (sin confirmación)
        window.deletePsychometricTest = function(testId) {
            if (!currentPsychometricStageId || !localTemplateCopy) return;
            const stage = localTemplateCopy.realContent.stages.find(s => s.id === currentPsychometricStageId);
            if (!stage || !stage.config || !stage.config.tests) return;
            
            // Eliminar directamente sin confirmación
            stage.config.tests = stage.config.tests.filter(t => t.id !== testId);
            renderPsychometricTestsView();
            renderTemplateFlow(localTemplateCopy);
            
            if (typeof showToast === 'function') {
                showToast('success', 'Prueba eliminada');
            }
        };

        // Guardar prueba psicométrica
        window.savePsychometricTest = function(testId) {
            if (!currentPsychometricStageId || !localTemplateCopy) return;
            
            const stage = localTemplateCopy.realContent.stages.find(s => s.id === currentPsychometricStageId);
            if (!stage) return;
            
            if (!stage.config) {
                stage.config = {};
            }
            if (!stage.config.tests) {
                stage.config.tests = [];
            }
            
            // Si no se proporciona testId, intentar obtenerlo del formulario
            if (!testId || testId === 'undefined') {
                const form = document.querySelector('.test-form');
                if (form) {
                    testId = form.getAttribute('data-test-id');
                }
                if (!testId) {
                    // Buscar en los contenedores
                    const typeContainer = document.querySelector('[id^="test-form-type-"]');
                    if (typeContainer) {
                        testId = typeContainer.id.replace('test-form-type-', '');
                    }
                }
                if (!testId) {
                    testId = 'test-' + Date.now();
                }
            }
            
            console.log('💾 Guardando prueba psicométrica:', { testId, currentPsychometricStageId });
            
            // Obtener valores del formulario (componentes UBITS)
            // Para selects UBITS, el valor está en dataset.selectedValue
            const typeContainer = document.getElementById(`test-form-type-${testId}`);
            const languageContainer = document.getElementById(`test-form-language-${testId}`);
            const minScoreContainer = document.getElementById(`test-form-minscore-${testId}`);
            
            console.log('📦 Contenedores encontrados:', {
                typeContainer: !!typeContainer,
                languageContainer: !!languageContainer,
                minScoreContainer: !!minScoreContainer
            });
            
            if (!typeContainer || !languageContainer || !minScoreContainer) {
                if (typeof showToast === 'function') {
                    showToast('error', 'Error: No se encontraron los campos del formulario');
                }
                console.error('❌ Contenedores no encontrados');
                return;
            }
            
            // Obtener input elements de los contenedores
            const typeInput = typeContainer.querySelector('.ubits-input');
            const languageInput = languageContainer.querySelector('.ubits-input');
            const minScoreInput = minScoreContainer.querySelector('.ubits-input');
            
            console.log('📝 Inputs encontrados:', {
                typeInput: !!typeInput,
                languageInput: !!languageInput,
                minScoreInput: !!minScoreInput
            });
            
            if (!typeInput || !languageInput || !minScoreInput) {
                if (typeof showToast === 'function') {
                    showToast('error', 'Error: No se encontraron los inputs UBITS');
                }
                console.error('❌ Inputs UBITS no encontrados');
                return;
            }
            
            // Para selects, obtener el valor de dataset.selectedValue, si no existe usar value
            const testType = typeInput.dataset.selectedValue || typeInput.value || '';
            const testLanguage = languageInput.dataset.selectedValue || languageInput.value || '';
            const minScore = parseFloat(minScoreInput.value) || 0;
            
            console.log('📋 Valores obtenidos:', { testType, testLanguage, minScore });
            
            // Validar que los valores requeridos estén presentes
            if (!testType || !testLanguage) {
                if (typeof showToast === 'function') {
                    showToast('error', 'Por favor completa todos los campos requeridos');
                }
                console.error('❌ Valores requeridos faltantes:', { testType, testLanguage });
                return;
            }
            
            const testData = {
                id: testId,
                type: testType,
                language: testLanguage,
                minScore: minScore
            };
            
            // Buscar si la prueba ya existe
            const testIndex = stage.config.tests.findIndex(t => t.id === testId);
            
            if (testIndex !== -1) {
                // Actualizar prueba existente
                stage.config.tests[testIndex] = testData;
                console.log('✅ Prueba actualizada');
            } else {
                // Agregar nueva prueba
                stage.config.tests.push(testData);
                console.log('✅ Prueba agregada');
            }
            
            // Volver a la vista de lista
            currentDrawerView = 'list';
            editingTestId = null;
            
            // Re-renderizar
            renderPsychometricTestsView();
            renderTemplateFlow(localTemplateCopy);
            
            if (typeof showToast === 'function') {
                showToast('success', 'Prueba guardada exitosamente');
            }
        };

        // Renderizar formulario de prueba
        function renderTestForm(test = null, testId = null) {
            const agentData = AGENTS.find(a => a.id === 'psychometric-analyst');
            if (!agentData) return '';
            
            const finalTestId = testId || (test ? test.id : 'test-' + Date.now());
            
            return `
                <div class="test-form" data-test-id="${finalTestId}">
                    <div class="test-form-fields">
                        <div class="test-form-field">
                            <label class="test-form-field-label-wrapper">
                                <span>Tipo de prueba (CI/CA)</span>
                                <button type="button" class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only test-form-info-btn" 
                                        data-tooltip="Selecciona el tipo de prueba psicométrica que se aplicará al candidato. Cada opción evalúa habilidades o aspectos distintos según la configuración de tu plataforma."
                                        title="Información">
                                    <i class="far fa-circle-info"></i>
                                </button>
                            </label>
                            <div id="test-form-type-${finalTestId}" class="config-input-container"></div>
                        </div>
                        <div class="test-form-field">
                            <label>Idioma de la prueba</label>
                            <div id="test-form-language-${finalTestId}" class="config-input-container"></div>
                        </div>
                        <div class="test-form-field">
                            <label class="test-form-field-label-wrapper">
                                <span>Puntaje CI mínimo</span>
                                <button type="button" class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only test-form-info-btn" 
                                        data-tooltip="Puntaje mínimo que el candidato debe lograr en la prueba psicométrica para considerarse aprobado en esta etapa."
                                        title="Información">
                                    <i class="far fa-circle-info"></i>
                                </button>
                            </label>
                            <div id="test-form-minscore-${finalTestId}" class="config-input-container"></div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Inicializar inputs del formulario
        function initializeTestFormInputs(testId = null) {
            if (!currentPsychometricStageId || !localTemplateCopy) return;
            
            const stage = localTemplateCopy.realContent.stages.find(s => s.id === currentPsychometricStageId);
            if (!stage) return;
            
            const agentData = AGENTS.find(a => a.id === 'psychometric-analyst');
            if (!agentData) return;
            
            // Obtener testId del formulario renderizado o del parámetro
            let finalTestId = testId;
            if (!finalTestId) {
                const form = document.querySelector('.test-form');
                if (form) {
                    finalTestId = form.getAttribute('data-test-id');
                }
            }
            
            if (!finalTestId) {
                // Buscar el testId en los IDs de los contenedores
                const typeContainer = document.querySelector('[id^="test-form-type-"]');
                if (typeContainer) {
                    finalTestId = typeContainer.id.replace('test-form-type-', '');
                }
            }
            
            if (!finalTestId) {
                console.error('❌ No se pudo obtener testId');
                return;
            }
            
            // Obtener valores por defecto o del test existente
            let testType = agentData.testTypes?.[0]?.value || 'personalidad-16';
            let testLanguage = agentData.testLanguages?.[0]?.value || 'es';
            let minScore = 0;
            
            if (editingTestId && editingTestId === finalTestId) {
                const test = stage.config?.tests?.find(t => t.id === editingTestId);
                if (test) {
                    testType = test.type;
                    testLanguage = test.language;
                    minScore = test.minScore || 0;
                }
            }
            
            console.log('  🔧 Inicializando inputs con:', { finalTestId, testType, testLanguage, minScore });
            
            // Crear select de tipo de prueba con componente UBITS
            const typeContainer = document.getElementById(`test-form-type-${finalTestId}`);
            if (typeContainer && typeof createInput !== 'undefined') {
                typeContainer.innerHTML = '';
                
                createInput({
                    containerId: `test-form-type-${finalTestId}`,
                    type: 'select',
                    label: '',
                    placeholder: 'Selecciona el tipo de prueba...',
                    value: testType,
                    selectOptions: agentData.testTypes.map(opt => ({
                        value: opt.value,
                        text: opt.text
                    }))
                });
                console.log('  ✅ Select de tipo creado');
            } else {
                console.error('❌ typeContainer no encontrado o createInput no disponible');
            }
            
            // Crear select de idioma con componente UBITS
            const languageContainer = document.getElementById(`test-form-language-${finalTestId}`);
            if (languageContainer && typeof createInput !== 'undefined') {
                console.log('  📦 languageContainer encontrado:', languageContainer);
                console.log('  📋 testLanguage:', testLanguage);
                console.log('  📋 agentData.testLanguages:', agentData.testLanguages);
                
                // Limpiar contenedor antes de crear
                languageContainer.innerHTML = '';
                
                try {
                    const languageSelectOptions = agentData.testLanguages ? agentData.testLanguages.map(opt => ({
                        value: opt.value,
                        text: opt.text
                    })) : [];
                    
                    console.log('  📋 languageSelectOptions:', languageSelectOptions);
                    
                    createInput({
                        containerId: `test-form-language-${finalTestId}`,
                        type: 'select',
                        label: '',
                        placeholder: 'Selecciona el idioma...',
                        value: testLanguage,
                        selectOptions: languageSelectOptions
                    });
                    
                    // Asegurar que el texto se establezca después de crear el select
                    setTimeout(() => {
                        const input = languageContainer.querySelector('.ubits-input');
                        if (input && testLanguage) {
                            // Buscar el texto correspondiente al valor
                            const option = agentData.testLanguages?.find(opt => opt.value === testLanguage);
                            if (option) {
                                input.value = option.text;
                                input.dataset.selectedValue = testLanguage;
                            }
                        }
                        console.log('  ✅ Select de idioma configurado. Input encontrado:', !!input);
                    }, 500);
                    
                    console.log('  ✅ Select de idioma creado');
                } catch (error) {
                    console.error('❌ Error al crear select de idioma:', error);
                    console.error('  Stack:', error.stack);
                }
            } else {
                console.error('❌ languageContainer no encontrado o createInput no disponible', {
                    languageContainer: !!languageContainer,
                    createInput: typeof createInput,
                    containerId: `test-form-language-${finalTestId}`
                });
            }
            
            // Crear input de puntaje mínimo con componente UBITS
            const minScoreContainer = document.getElementById(`test-form-minscore-${finalTestId}`);
            if (minScoreContainer) {
                console.log('  📦 minScoreContainer encontrado:', minScoreContainer);
                if (typeof createInput === 'undefined') {
                    console.error('❌ createInput no está disponible');
                    return;
                }
                
                // Limpiar contenedor antes de crear
                minScoreContainer.innerHTML = '';
                
                try {
                    createInput({
                        containerId: `test-form-minscore-${finalTestId}`,
                        type: 'number',
                        label: '',
                        placeholder: '0',
                        value: minScore.toString(),
                        helperText: 'Opcional: puntaje mínimo que debe obtener el candidato en esta prueba'
                    });
                    console.log('  ✅ Input de puntaje mínimo creado');
                } catch (error) {
                    console.error('❌ Error al crear input de puntaje mínimo:', error);
                }
            } else {
                console.error('❌ minScoreContainer no encontrado. ID buscado:', `test-form-minscore-${finalTestId}`);
            }
        }

        // Abrir drawer de configuración de Serena
        window.openSerenaConfigDrawer = function(stageId) {
            if (!isEditMode || !localTemplateCopy) return;
            currentSerenaStageId = stageId;
            
            const drawer = document.getElementById('serenaConfigDrawer');
            if (drawer) {
                drawer.classList.add('active');
                renderSerenaConfigView();
            }
        };

        // Cerrar drawer de configuración de Serena
        window.closeSerenaConfigDrawer = function() {
            const drawer = document.getElementById('serenaConfigDrawer');
            if (drawer) {
                drawer.classList.remove('active');
            }
            currentSerenaStageId = null;
        };

        // Manejar click en overlay de Serena
        window.handleSerenaDrawerOverlayClick = function(event) {
            if (event.target.closest('.drawer-content')) {
                event.stopPropagation();
                event.preventDefault();
                return false;
            }
            closeSerenaConfigDrawer();
        };

        // Renderizar vista de configuración de Serena
        function renderSerenaConfigView() {
            if (!currentSerenaStageId || !localTemplateCopy) return;
            
            const contentContainer = document.getElementById('serenaConfigContent');
            const footerActions = document.getElementById('serenaDrawerFooterActions');
            
            if (!contentContainer) return;
            
            const stage = localTemplateCopy.realContent.stages.find(s => s.id === currentSerenaStageId);
            if (!stage) return;
            
            const agentData = AGENTS.find(a => a.id === 'interview-ia');
            if (!agentData) return;
            
            const interviewType = stage.config?.interviewType || agentData.config.interviewType.default;
            const voice = stage.config?.voice || agentData.config.voice.default;
            const expirationDays = stage.config?.expirationDays ?? agentData.config.expirationDays.default;
            const minScore = stage.config?.minScore ?? agentData.config.minScore.default;
            
            contentContainer.innerHTML = `
                <div class="serena-section">
                    <h4 class="serena-section-title">Tipo de entrevista</h4>
                    <p class="serena-section-description">Elige cómo prefieres que Serena interactúe con tus candidatos:</p>
                    <div class="interview-type-cards">
                        <div class="interview-type-card ${interviewType === 'telefonica' ? 'selected' : ''}" 
                             onclick="selectInterviewType('telefonica')">
                            <label class="config-radio-label" onclick="event.stopPropagation();">
                                <input 
                                    type="radio" 
                                    name="serena-interview-type-${currentSerenaStageId}"
                                    value="telefonica"
                                    ${interviewType === 'telefonica' ? 'checked' : ''}
                                    onchange="selectInterviewType('telefonica')"
                                >
                                <span></span>
                            </label>
                            <div class="interview-type-card-content">
                                <i class="far fa-phone interview-type-card-icon"></i>
                                <span class="interview-type-card-label">Telefónica</span>
                            </div>
                        </div>
                        <div class="interview-type-card ${interviewType === 'virtual' ? 'selected' : ''}" 
                             onclick="selectInterviewType('virtual')">
                            <label class="config-radio-label" onclick="event.stopPropagation();">
                                <input 
                                    type="radio" 
                                    name="serena-interview-type-${currentSerenaStageId}"
                                    value="virtual"
                                    ${interviewType === 'virtual' ? 'checked' : ''}
                                    onchange="selectInterviewType('virtual')"
                                >
                                <span></span>
                            </label>
                            <div class="interview-type-card-content">
                                <i class="far fa-laptop interview-type-card-icon"></i>
                                <span class="interview-type-card-label">Virtual</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="serena-section">
                    <h4 class="serena-section-title">Voz de Serena</h4>
                    <p class="serena-section-description">Selecciona la voz que utilizará Serena durante la entrevista:</p>
                    <div id="serena-voice-select-container"></div>
                </div>
                
                <div class="serena-section">
                    <h4 class="serena-section-title">Configuración adicional</h4>
                    <div class="serena-config-fields">
                        <div class="serena-config-field">
                            <div class="serena-config-field-label-wrapper">
                                <label class="serena-config-field-label">Días para que expire la entrevista</label>
                                <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only config-info-btn" data-tooltip="Cantidad de días que el candidato tiene para completar la entrevista desde que recibe la invitación. Si no responde dentro de ese plazo, la entrevista vence y ya no podrá realizarla." title="Información">
                                    <i class="far fa-info-circle"></i>
                                </button>
                            </div>
                            <div id="serena-expiration-days-container"></div>
                        </div>
                        <div class="serena-config-field">
                            <div class="serena-config-field-label-wrapper">
                                <label class="serena-config-field-label">Puntaje mínimo de la entrevista</label>
                                <button class="ubits-button ubits-button--tertiary ubits-button--sm ubits-button--icon-only config-info-btn" data-tooltip="Puntaje mínimo que el candidato debe obtener en la entrevista para avanzar a la siguiente etapa del proceso." title="Información">
                                    <i class="far fa-info-circle"></i>
                                </button>
                            </div>
                            <div id="serena-min-score-container"></div>
                        </div>
                    </div>
                </div>
            `;
            
            if (footerActions) {
                footerActions.innerHTML = `
                    <button class="ubits-button ubits-button--secondary ubits-button--md" onclick="closeSerenaConfigDrawer(); return false;">
                        <span>Cancelar</span>
                    </button>
                    <button class="ubits-button ubits-button--primary ubits-button--md" onclick="saveSerenaConfig(); return false;">
                        <i class="far fa-save"></i>
                        <span>Guardar</span>
                    </button>
                `;
            }
            
            setTimeout(() => {
                // Select de voz
                const voiceSelectContainer = document.getElementById('serena-voice-select-container');
                if (voiceSelectContainer && agentData.voices) {
                    createInput({
                        containerId: 'serena-voice-select-container',
                        type: 'select',
                        placeholder: 'Selecciona una voz...',
                        selectOptions: agentData.voices.map(v => ({
                            value: v.id,
                            text: `${v.flag} ${v.name}`
                        })),
                        value: voice,
                        onChange: function(newValue) {
                            if (stage) {
                                if (!stage.config) stage.config = {};
                                stage.config.voice = newValue;
                            }
                        }
                    });
                }
                
                // Input de días de expiración
                const expirationContainer = document.getElementById('serena-expiration-days-container');
                if (expirationContainer) {
                    createInput({
                        containerId: 'serena-expiration-days-container',
                        type: 'number',
                        placeholder: '0',
                        value: expirationDays,
                        min: 0,
                        onChange: function(newValue) {
                            if (stage) {
                                if (!stage.config) stage.config = {};
                                stage.config.expirationDays = parseFloat(newValue) || 0;
                            }
                        }
                    });
                }
                
                // Input de puntaje mínimo
                const minScoreContainer = document.getElementById('serena-min-score-container');
                if (minScoreContainer) {
                    createInput({
                        containerId: 'serena-min-score-container',
                        type: 'number',
                        placeholder: '0',
                        value: minScore,
                        min: 0,
                        onChange: function(newValue) {
                            if (stage) {
                                if (!stage.config) stage.config = {};
                                stage.config.minScore = parseFloat(newValue) || 0;
                            }
                        }
                    });
                }
                
                // Agregar event listeners para tooltips de campos de configuración
                const drawer = document.getElementById('serenaConfigDrawer');
                if (drawer) {
                    drawer.querySelectorAll('.config-info-btn').forEach(btn => {
                        btn.addEventListener('mouseenter', handleConfigInfoHover);
                        btn.addEventListener('mouseleave', handleConfigInfoLeave);
                    });
                }
            }, 300);
        }

        // ========================================
        // FUNCIONES PARA TOOLTIP DE INFORMACIÓN DE CAMPOS DE CONFIGURACIÓN
        // ========================================
        
        function handleConfigInfoHover(e) {
            const btn = e.currentTarget;
            const tooltip = document.getElementById('tooltip');
            if (!tooltip) {
                console.warn('⚠️ Tooltip element not found in handleConfigInfoHover');
                return;
            }
            
            const tooltipText = btn.getAttribute('data-tooltip');
            if (!tooltipText) {
                console.warn('⚠️ No tooltip text found on button');
                return;
            }
            
            // Agregar clase específica para tooltip de configuración
            tooltip.classList.add('config-info-tooltip');
            
            // Asegurar que el tooltip esté por encima del drawer (z-index: 10001)
            tooltip.style.zIndex = '10002';
            
            // Crear contenido del tooltip
            tooltip.innerHTML = `
                <div style="font-size: 13px; line-height: 1.4; color: var(--ubits-fg-1-high-static-inverted);">${tooltipText}</div>
            `;
            
            // Mostrar tooltip temporalmente para obtener dimensiones reales
            tooltip.style.opacity = '0';
            tooltip.style.visibility = 'hidden';
            tooltip.style.display = 'block';
            tooltip.style.position = 'fixed';
            
            // Obtener dimensiones reales del tooltip
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            
            // Obtener posición del botón
            const rect = btn.getBoundingClientRect();
            const btnCenterX = rect.left + (rect.width / 2);
            const btnTop = rect.top;
            
            // Calcular espacio disponible
            const spaceTop = rect.top;
            const spaceBottom = window.innerHeight - rect.bottom;
            const spaceLeft = rect.left;
            const spaceRight = window.innerWidth - rect.right;
            
            // Posicionar tooltip centrado arriba del botón
            let finalLeft = btnCenterX - (tooltipWidth / 2);
            let finalTop = btnTop - tooltipHeight - 8; // 8px de espacio entre botón y tooltip
            
            // Ajustar si se sale por la izquierda
            if (finalLeft < 8) {
                finalLeft = 8;
            }
            
            // Ajustar si se sale por la derecha
            if (finalLeft + tooltipWidth > window.innerWidth - 8) {
                finalLeft = window.innerWidth - tooltipWidth - 8;
            }
            
            // Si no hay espacio arriba, mostrar abajo
            if (spaceTop < tooltipHeight + 8) {
                finalTop = rect.bottom + 8;
            }
            
            // Aplicar posición final
            tooltip.style.left = finalLeft + 'px';
            tooltip.style.top = finalTop + 'px';
            tooltip.style.transform = 'none';
            tooltip.style.visibility = 'visible';
            tooltip.style.opacity = '1';
        }

        function handleConfigInfoLeave(e) {
            const tooltip = document.getElementById('tooltip');
            if (!tooltip) return;
            
            tooltip.style.opacity = '0';
            tooltip.style.zIndex = '10000'; // Restaurar z-index por defecto
            tooltip.classList.remove('config-info-tooltip');
        }

        // ========================================
        // FUNCIONES PARA TOOLTIP DE INFORMACIÓN DE AGENTES
        // ========================================
        
        function handleAgentInfoHover(e) {
            const btn = e.currentTarget;
            const tooltip = document.getElementById('tooltip');
            if (!tooltip) return;
            
            const agentName = btn.getAttribute('data-agent-name');
            const agentDescription = btn.getAttribute('data-agent-description');
            
            // Agregar clase específica para tooltip de agentes
            tooltip.classList.add('agent-info-tooltip');
            
            // Crear contenido del tooltip con título y descripción
            tooltip.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 4px; color: var(--ubits-fg-1-high-static-inverted);">${agentName}</div>
                <div style="font-size: 13px; line-height: 1.4; color: var(--ubits-fg-1-high-static-inverted);">${agentDescription}</div>
            `;
            
            // Mostrar tooltip
            tooltip.style.opacity = '1';
            
            // Posicionar tooltip arriba del botón
            const rect = btn.getBoundingClientRect();
            
            // Encontrar la posición exacta del icono dentro del botón
            const icon = btn.querySelector('i');
            let iconRect = null;
            let iconCenterX = rect.left + (rect.width / 2);
            let iconCenterY = rect.top + (rect.height / 2);
            
            if (icon) {
                iconRect = icon.getBoundingClientRect();
                iconCenterX = iconRect.left + (iconRect.width / 2);
                iconCenterY = iconRect.top + (iconRect.height / 2);
            }
            
            // Detectar si el botón está en una card del board (paso del proceso)
            const isInBoard = btn.closest('.board-container') !== null;
            const isInBoardStage = btn.closest('.agent-stage-item') !== null;
            
            // Calcular espacio disponible a izquierda y derecha
            const spaceLeft = rect.left;
            const spaceRight = window.innerWidth - rect.right;
            
            // Estimar ancho del tooltip (usar max-width como referencia)
            const estimatedTooltipWidth = 400; // max-width del tooltip
            
            // Decidir posición inicial basada en espacio disponible
            let initialLeft, initialTransform, finalLeft, finalTop;
            
            // Posicionar desde el borde derecho del icono (no desde el centro)
            const tooltipOffsetFromIcon = 12; // Distancia entre el icono y el tooltip
            
            // Calcular posición vertical (arriba del icono)
            const tooltipTop = iconRect ? (iconRect.top - tooltipOffsetFromIcon) : (rect.top - tooltipOffsetFromIcon);
            
            // Usar el borde IZQUIERDO o DERECHO del icono según la ubicación
            const iconLeftEdge = iconRect ? iconRect.left : rect.left;
            const iconRightEdge = iconRect ? iconRect.right : rect.right;
            
            // Si está en el board (paso del proceso), alinear a la derecha del icono
            if (isInBoard || isInBoardStage) {
                const gapFromIcon = 4;
                
                if (spaceRight >= estimatedTooltipWidth + gapFromIcon) {
                    initialLeft = (iconRightEdge + gapFromIcon) + 'px';
                    initialTransform = 'translateY(-100%)';
                } else {
                    initialLeft = iconRightEdge + 'px';
                    initialTransform = 'translateX(-100%) translateY(-100%)';
                }
            } else {
                // Si está en el sidebar (lista de agentes), mantener alineado a la izquierda
                if (spaceRight >= 200) {
                    initialLeft = iconLeftEdge + 'px';
                    initialTransform = 'translateY(-100%)';
                } else if (spaceLeft >= 200) {
                    initialLeft = iconLeftEdge + 'px';
                    initialTransform = 'translateX(-100%) translateY(-100%)';
                } else {
                    if (spaceRight >= spaceLeft) {
                        initialLeft = iconLeftEdge + 'px';
                        initialTransform = 'translateY(-100%)';
                    } else {
                        initialLeft = iconLeftEdge + 'px';
                        initialTransform = 'translateX(-100%) translateY(-100%)';
                    }
                }
            }
            
            finalLeft = initialLeft;
            finalTop = tooltipTop + 'px';
            
            tooltip.style.left = finalLeft;
            tooltip.style.top = finalTop;
            tooltip.style.transform = initialTransform;
            
            // Asegurar que el tooltip use position fixed
            tooltip.style.position = 'fixed';
            
            // Calcular el ancho máximo disponible según la dirección de expansión
            let tooltipMaxWidth = 400;
            
            if (isInBoard || isInBoardStage) {
                const leftPosition = parseFloat(finalLeft.replace('px', ''));
                
                if (initialTransform === 'translateY(-100%)') {
                    const maxAvailableWidth = window.innerWidth - leftPosition - 12;
                    tooltipMaxWidth = Math.min(400, Math.max(250, maxAvailableWidth));
                } else {
                    const maxAvailableWidth = leftPosition - 12;
                    tooltipMaxWidth = Math.min(400, Math.max(250, maxAvailableWidth));
                }
            }
            
            tooltip.style.maxWidth = tooltipMaxWidth + 'px';
        }

        function handleAgentInfoLeave(e) {
            const tooltip = document.getElementById('tooltip');
            if (!tooltip) return;
            
            tooltip.style.opacity = '0';
            tooltip.classList.remove('agent-info-tooltip');
            tooltip.style.transform = '';
        }

        // Seleccionar tipo de entrevista
        window.selectInterviewType = function(type) {
            if (!currentSerenaStageId || !localTemplateCopy) return;
            
            const stage = localTemplateCopy.realContent.stages.find(s => s.id === currentSerenaStageId);
            if (!stage) return;
            
            if (!stage.config) stage.config = {};
            stage.config.interviewType = type;
            
            renderSerenaConfigView();
        };

        // Guardar configuración de Serena
        window.saveSerenaConfig = function() {
            if (!currentSerenaStageId || !localTemplateCopy) return;
            
            const stage = localTemplateCopy.realContent.stages.find(s => s.id === currentSerenaStageId);
            if (!stage) return;
            
            // Los valores ya se están actualizando con los onChange de los inputs
            // Solo necesitamos re-renderizar el flujo y cerrar el drawer
            renderTemplateFlow(localTemplateCopy);
            closeSerenaConfigDrawer();
            
            if (typeof showToast === 'function') {
                showToast('success', 'Configuración de Serena guardada');
            }
        };

        // Renderizar agentes en la biblioteca
        function renderAgents() {
            const agentsList = document.getElementById('agentsList');
            if (!agentsList) return;
            
            // Filtrar agentes que ya están en uso
            const usedAgentIds = localTemplateCopy?.realContent?.stages
                .filter(s => s.type === 'agent' && s.agentId)
                .map(s => s.agentId) || [];
            
            const availableAgents = AGENTS.filter(agent => !usedAgentIds.includes(agent.id));
            
            // Mostrar empty state si todos los agentes están en uso
            if (availableAgents.length === 0) {
                agentsList.innerHTML = `
                    <div class="empty-stages-visual">
                        <div class="empty-icon">
                            <i class="far fa-check-circle"></i>
                        </div>
                        <p class="empty-text">Todos los agentes de IA están en uso en esta plantilla</p>
                    </div>
                `;
                return;
            }
            
            agentsList.innerHTML = availableAgents.map(agent => {
                // Descripción corta para mostrar en la card
                const descriptions = {
                    'cv-analyzer': 'Analiza CV y asigna puntaje',
                    'interview-ia': 'Genera preguntas y analiza respuestas',
                    'psychometric-analyst': 'Evalúa mediante pruebas psicométricas',
                    'background-check': 'Verifica certificado de antecedentes judiciales'
                };
                const agentDescription = descriptions[agent.id] || agent.description;
                
                // Descripción larga para el tooltip del botón de información
                const agentTooltips = {
                    'cv-analyzer': 'Este agente revisa automáticamente los CV, evalúa la experiencia del candidato y verifica que su expectativa salarial esté alineada con el rango de la vacante.',
                    'interview-ia': 'Esta IA realiza entrevistas automáticas por teléfono o entrevista virtual, analiza las respuestas del candidato y asigna un puntaje según sus competencias y forma de responder.',
                    'psychometric-analyst': 'Este agente aplica pruebas psicométricas al candidato y calcula un puntaje que refleja sus capacidades cognitivas y/o rasgos relevantes para el puesto.',
                    'background-check': 'Permite generar y verificar el certificado de antecedentes judiciales del candidato para validar su historial legal de forma segura.'
                };
                const agentTooltip = agentTooltips[agent.id] || agentDescription;
                
                return `
                <div class="agent-item" 
                     draggable="true" 
                     data-agent-id="${agent.id}"
                     data-agent-name="${agent.name}"
                     data-agent-icon="${agent.icon}">
                    <div class="agent-header">
                        <div class="agent-title-section">
                            <div class="agent-icon"><i class="far ${agent.icon}"></i></div>
                            <div class="agent-name">${agent.name} (IA)</div>
                        </div>
                        <div class="agent-actions">
                            <button class="ubits-button ubits-button--secondary ubits-button--sm ubits-button--icon-only" 
                                    onclick="addAgentToFlow('${agent.id}')" 
                                    title="Agregar al flujo">
                                <i class="far fa-plus"></i>
                            </button>
                        </div>
                    </div>
                    <div class="agent-help">${agentDescription}</div>
                </div>
            `;
            }).join('');
            
            // Agregar event listeners para drag and drop
            if (agentsList) {
                agentsList.querySelectorAll('.agent-item').forEach(item => {
                    item.addEventListener('dragstart', handleAgentDragStart);
                    item.addEventListener('dragend', handleAgentDragEnd);
                });
            }
        }

        // Agregar agente al flujo

        // Abrir drawer de pruebas psicométricas (stub - por ahora solo muestra toast)
        function openPsychometricTestsDrawer(stageId) {
            if (!isEditMode) return;
            showToast('info', 'La gestión de pruebas psicométricas se implementará próximamente');
        }

        // Abrir drawer de configuración de Serena (stub - por ahora solo muestra toast)
        function openSerenaConfigDrawer(stageId) {
            if (!isEditMode) return;
            showToast('info', 'La configuración de entrevista Serena se implementará próximamente');
        }

        // ========================================
        // DRAG AND DROP HANDLERS
        // ========================================

        let draggedElement = null;
        let draggedBoardStage = null;
        let currentDropTarget = null;

        // Drag and drop para agentes
        function handleAgentDragStart(e) {
            const agentItem = e.target.closest('.agent-item');
            if (!agentItem) return;
            
            const agentId = agentItem.getAttribute('data-agent-id');
            const agentName = agentItem.getAttribute('data-agent-name');
            const agentIcon = agentItem.getAttribute('data-agent-icon');
            
            console.log('🔧 [handleAgentDragStart] Iniciando arrastre de agente:', agentName);
            console.log('🔧 [handleAgentDragStart] agentId:', agentId);
            console.log('🔧 [handleAgentDragStart] agentName:', agentName);
            console.log('🔧 [handleAgentDragStart] agentIcon:', agentIcon);
            
            // Guardar datos del elemento arrastrado
            draggedElement = {
                type: 'agent',
                id: agentId,
                name: agentName,
                icon: agentIcon,
                element: agentItem
            };
            
            console.log('🔧 [handleAgentDragStart] draggedElement guardado:', draggedElement);
            
            // Agregar clase de arrastre
            agentItem.classList.add('dragging');
            
            // Configurar datos de transferencia
            const transferData = {
                type: 'agent',
                id: agentId,
                name: agentName,
                icon: agentIcon
            };
            
            try {
                e.dataTransfer.setData('text/plain', JSON.stringify(transferData));
                console.log('✅ [handleAgentDragStart] Datos configurados en dataTransfer:', transferData);
            } catch (err) {
                console.error('❌ [handleAgentDragStart] Error al configurar dataTransfer:', err);
            }
            
            // Configurar efecto de arrastre
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleAgentDragEnd(e) {
            const agentItem = e.target.closest('.agent-item');
            if (agentItem) {
                agentItem.classList.remove('dragging');
            }
            // NO limpiar draggedElement aquí, se limpiará después de procesar el drop
            // Usar timeout para limpiar después de que se procese el drop
            setTimeout(() => {
                draggedElement = null;
            }, 100);
        }

        // Drag and drop para etapas
        function handleStageTemplateDragStart(event) {
            const stageItem = event.target.closest('.stage-item');
            if (!stageItem) return;
            
            const stageId = stageItem.getAttribute('data-stage-id');
            const stageName = stageItem.getAttribute('data-stage-name');
            const stageCategory = stageItem.getAttribute('data-stage-category');
            
            // Guardar datos del elemento arrastrado
            draggedElement = {
                type: 'stage-template',
                id: stageId,
                name: stageName,
                category: stageCategory,
                element: stageItem
            };
            
            // Agregar clase de arrastre
            stageItem.classList.add('dragging');
            
            // Configurar datos de transferencia
            const dragData = {
                type: 'stage-template',
                id: stageId,
                name: stageName,
                category: stageCategory
            };
            
            // Intentar múltiples formatos para compatibilidad
            try {
                event.dataTransfer.setData('text/plain', JSON.stringify(dragData));
                event.dataTransfer.setData('application/json', JSON.stringify(dragData));
            } catch (e) {
                console.error('Error al configurar dataTransfer:', e);
            }
            
            // Configurar efecto de arrastre
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.dropEffect = 'move';
            
            console.log('🔧 [handleStageTemplateDragStart] Iniciando arrastre de etapa:', stageName);
            console.log('🔧 [handleStageTemplateDragStart] Datos configurados:', dragData);
        }

        function handleStageTemplateDragEnd(event) {
            const stageItem = event.target.closest('.stage-item');
            if (stageItem) {
                stageItem.classList.remove('dragging');
            }
            // NO limpiar draggedElement aquí, se limpiará después de procesar el drop
            // Usar timeout para limpiar después de que se procese el drop
            setTimeout(() => {
                draggedElement = null;
            }, 100);
        }

        // Hacer el board droppable
        // Guardar referencias a los handlers para poder removerlos
        let boardDragOverHandler = null;
        let boardDragLeaveHandler = null;
        let boardDropHandler = null;

        function makeBoardDroppable() {
            const flowContainer = document.getElementById('template-flow-container');
            const boardContainer = document.querySelector('.board-container');
            
            if (!flowContainer || !boardContainer) return;
            
            // Remover listeners anteriores si existen
            if (boardDragOverHandler) {
                boardContainer.removeEventListener('dragover', boardDragOverHandler);
            }
            if (boardDragLeaveHandler) {
                boardContainer.removeEventListener('dragleave', boardDragLeaveHandler);
            }
            if (boardDropHandler) {
                boardContainer.removeEventListener('drop', boardDropHandler);
            }
            
            // Función para manejar drag over
            boardDragOverHandler = function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                boardContainer.classList.add('drag-over');
            };
            
            // Función para manejar drag leave
            boardDragLeaveHandler = function(e) {
                if (!boardContainer.contains(e.relatedTarget)) {
                    boardContainer.classList.remove('drag-over');
                }
            };
            
            // Función para manejar drop
            boardDropHandler = function(e) {
                e.preventDefault();
                boardContainer.classList.remove('drag-over');
                
                console.log('🔧 [boardDropHandler] ========== DROP EVENT ==========');
                console.log('🔧 [boardDropHandler] draggedElement actual:', draggedElement);
                
                try {
                    // Intentar obtener datos de múltiples formatos
                    let rawData = e.dataTransfer.getData('text/plain');
                    if (!rawData || rawData.trim().length === 0) {
                        rawData = e.dataTransfer.getData('application/json');
                    }
                    
                    console.log('🔍 [boardDropHandler] rawData recibido en drop:', rawData);
                    console.log('🔍 [boardDropHandler] rawData length:', rawData ? rawData.length : 0);
                    
                    let data = null;
                    
                    // Intentar parsear solo si hay datos
                    if (rawData && rawData.trim().length > 0) {
                        try {
                            data = JSON.parse(rawData);
                            console.log('✅ [boardDropHandler] Datos parseados desde dataTransfer:', data);
                        } catch (parseError) {
                            console.warn('⚠️ [boardDropHandler] Error al parsear dataTransfer:', parseError);
                            console.warn('⚠️ [boardDropHandler] rawData que causó el error:', rawData);
                        }
                    } else {
                        console.warn('⚠️ [boardDropHandler] dataTransfer.getData() vacío o inválido');
                        console.warn('⚠️ [boardDropHandler] Intentando usar draggedElement como respaldo...');
                    }
                    
                    // Si no se pudo obtener datos desde dataTransfer, usar draggedElement como respaldo
                    if (!data && draggedElement) {
                        console.log('🔧 [boardDropHandler] Usando draggedElement como fuente de datos:', draggedElement);
                        data = {
                            type: draggedElement.type || 'stage-template',
                            id: draggedElement.id,
                            name: draggedElement.name,
                            category: draggedElement.category,
                            icon: draggedElement.icon
                        };
                    }
                    
                    console.log('🔧 [boardDropHandler] data final antes de procesar:', data);
                    
                    // Si aún no hay datos válidos, no hacer nada
                    if (!data || !data.type) {
                        console.error('❌ [boardDropHandler] No se pudieron obtener datos válidos para el drop.');
                        console.error('❌ [boardDropHandler] data:', data);
                        console.error('❌ [boardDropHandler] draggedElement:', draggedElement);
                        return;
                    }
                    
                    console.log('🔧 [boardDropHandler] Procesando drop con tipo:', data.type);
                    
                    if (data.type === 'stage-template') {
                        handleStageTemplateDrop(data);
                    } else if (data.type === 'agent') {
                        handleAgentDrop(data);
                    } else {
                        console.warn('⚠️ [boardDropHandler] Tipo de dato desconocido en drop:', data.type);
                    }
                    
                    // Limpiar draggedElement después de procesar exitosamente
                    draggedElement = null;
                    console.log('✅ [boardDropHandler] draggedElement limpiado después del drop');
                } catch (error) {
                    console.error('❌ [boardDropHandler] Error al procesar drop:', error);
                    console.error('❌ [boardDropHandler] Stack trace:', error.stack);
                }
                
                console.log('✅ [boardDropHandler] ========== FIN DE DROP EVENT ==========');
            };
            
            // Agregar event listeners al board-container
            boardContainer.addEventListener('dragover', boardDragOverHandler);
            boardContainer.addEventListener('dragleave', boardDragLeaveHandler);
            boardContainer.addEventListener('drop', boardDropHandler);
        }

        // ========================================
        // DRAG AND DROP PARA REORDENAR ETAPAS EN EL BOARD
        // ========================================

        function handleBoardStageDragStart(e) {
            const stageItem = e.target.closest('.stage-item');
            if (!stageItem) return;
            
            // Solo permitir reordenar en modo edición
            if (!isEditMode) {
                e.preventDefault();
                return;
            }
            
            draggedBoardStage = stageItem;
            stageItem.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', 'board-stage-reorder');
            
            console.log('🔧 Iniciando arrastre de etapa del board para reordenar');
        }

        function handleBoardStageDragOver(e) {
            // Si NO es reordenamiento del board, dejar que el evento se propague
            // para que el board-container lo maneje (agentes/etapas desde columna izquierda)
            if (!draggedBoardStage) {
                // NO hacer preventDefault() - dejar que llegue al board-container
                return;
            }
            
            // SOLO si es reordenamiento del board, prevenir y manejar
            e.preventDefault();
            e.stopPropagation();
            
            const targetItem = e.target.closest('.stage-item');
            if (!targetItem) return;
            
            e.dataTransfer.dropEffect = 'move';
            
            // No hacer nada si es el mismo elemento
            if (targetItem === draggedBoardStage) return;
            
            // Obtener el contenedor de etapas
            const container = document.querySelector('.board-container');
            if (!container) return;
            
            // Obtener todos los elementos de etapa
            const allStages = [...container.querySelectorAll('.stage-item')];
            const draggedIndex = allStages.indexOf(draggedBoardStage);
            const targetIndex = allStages.indexOf(targetItem);
            
            // Insertar el elemento arrastrado antes o después del objetivo
            if (draggedIndex < targetIndex) {
                targetItem.parentNode.insertBefore(draggedBoardStage, targetItem.nextSibling);
            } else {
                targetItem.parentNode.insertBefore(draggedBoardStage, targetItem);
            }
        }

        function handleBoardStageDragLeave(e) {
            // Solo restaurar si estamos reordenando etapas del board
            if (!draggedBoardStage) return;
            
            const targetItem = e.target.closest('.stage-item');
            if (!targetItem || targetItem === draggedBoardStage) return;
            
            targetItem.style.background = '';
            targetItem.style.borderColor = '';
        }

        function handleBoardStageDrop(e) {
            // Si NO es reordenamiento del board, dejar que el evento se propague
            // para que el board-container lo maneje
            if (!draggedBoardStage) {
                // NO hacer preventDefault() - dejar que llegue al board-container
                return;
            }
            
            // SOLO si es reordenamiento, prevenir y manejar
            e.preventDefault();
            e.stopPropagation();
            
            const targetItem = e.target.closest('.stage-item');
            if (!targetItem) return;
            
            // Restaurar estilos
            targetItem.style.borderColor = '';
        }

        function handleBoardStageDragEnd(e) {
            const stageItem = e.target.closest('.stage-item');
            if (stageItem) {
                stageItem.classList.remove('dragging');
                stageItem.style.background = '';
                stageItem.style.borderColor = '';
            }
            
            // Limpiar todos los estilos de feedback
            const allStages = document.querySelectorAll('.stage-item');
            allStages.forEach(stage => {
                stage.style.background = '';
                stage.style.borderColor = '';
            });
            
            // Actualizar el orden en el modelo de datos si estamos reordenando
            if (draggedBoardStage) {
                updateStageOrder();
            }
            
            draggedBoardStage = null;
            currentDropTarget = null;
            console.log('✅ Finalizando arrastre');
        }

        function updateStageOrder() {
            const container = document.querySelector('.board-container');
            if (!container || !localTemplateCopy) return;
            
            const stageElements = [...container.querySelectorAll('.stage-item')];
            const newOrder = stageElements.map(el => el.getAttribute('data-stage-id'));
            
            // Reordenar el array de etapas según el nuevo orden visual
            const reorderedStages = [];
            newOrder.forEach(stageId => {
                const stage = localTemplateCopy.realContent.stages.find(s => s.id === stageId);
                if (stage) {
                    reorderedStages.push(stage);
                }
            });
            
            localTemplateCopy.realContent.stages = reorderedStages;
            
            console.log('✅ Orden de etapas actualizado:', newOrder);
            
            // Re-renderizar para actualizar los números
            renderTemplateFlow(localTemplateCopy);
        }

        // Manejar drop de etapa
        function handleStageTemplateDrop(data) {
            if (!localTemplateCopy || !isEditMode) return;
            
            const { id, name, category } = data;
            
            // Verificar que la etapa no esté ya en uso
            const existingStage = localTemplateCopy.realContent.stages.find(stage => stage.templateId === id);
            if (existingStage) {
                showToast('info', 'Esta etapa ya está en el flujo');
                return;
            }
            
            // Buscar template de etapa para obtener tipo y descripción
            const stageTemplate = availableStages.find(s => s.id === id);
            
            // Crear nueva etapa en el área de trabajo
            const newStage = {
                id: 'work-stage-' + Date.now(),
                templateId: id,
                name: name,
                category: category,
                type: stageTemplate?.type || 'custom',
                description: stageTemplate?.description || ''
            };
            
            // Agregar a la plantilla actual
            localTemplateCopy.realContent.stages.push(newStage);
            
            // Re-renderizar todo
            renderTemplateFlow(localTemplateCopy);
            renderStages();
            
            showToast('success', `Etapa "${name}" agregada al flujo`);
        }

        // Manejar drop de agente
        function handleAgentDrop(data) {
            if (!localTemplateCopy || !isEditMode) return;
            
            const { id, name, icon } = data;
            
            // Buscar datos completos del agente
            const agentData = AGENTS.find(a => a.id === id);
            if (!agentData) return;
            
            // Verificar que este agente no esté ya en el flujo
            const existingAgentStage = localTemplateCopy.realContent.stages.find(stage => 
                stage.type === 'agent' && stage.agentId === id
            );
            
            if (existingAgentStage) {
                showToast('info', 'Este agente ya está en el flujo');
                return;
            }
            
            // Crear configuración por defecto del agente si tiene config
            let defaultConfig = {};
            if (agentData.hasConfig && agentData.config) {
                Object.entries(agentData.config).forEach(([key, field]) => {
                    if (key === 'tests' && field.type === 'psychometric-tests-manager') {
                        defaultConfig[key] = [];
                    } else {
                        defaultConfig[key] = field.default;
                    }
                });
            }
            
            // Crear nueva etapa tipo 'agent'
            const newAgentStage = {
                id: 'agent-stage-' + Date.now(),
                type: 'agent',
                agentId: id,
                name: agentData.name,
                icon: agentData.icon,
                category: agentData.category,
                hasConfig: agentData.hasConfig,
                config: defaultConfig,
                expanded: false
            };
            
            // Agregar al final del flujo
            localTemplateCopy.realContent.stages.push(newAgentStage);
            
            // Re-renderizar todo
            renderTemplateFlow(localTemplateCopy);
            renderAgents();
            
            // Si es analista psicométrico, abrir drawer automáticamente en modo creación
            if (id === 'psychometric-analyst') {
                setTimeout(() => {
                    if (!localTemplateCopy || !isEditMode) return;
                    // Abrir drawer y establecer directamente en modo creación
                    currentPsychometricStageId = newAgentStage.id;
                    editingTestId = null;
                    currentDrawerView = 'create'; // Establecer directamente en modo creación
                    
                    const drawer = document.getElementById('psychometricTestsDrawer');
                    if (drawer) {
                        drawer.classList.add('active');
                        renderPsychometricTestsView();
                    }
                }, 300);
            }
            
            // Si es entrevista Serena, abrir drawer de configuración automáticamente
            if (id === 'interview-ia') {
                setTimeout(() => {
                    if (typeof window.openSerenaConfigDrawer === 'function') {
                        window.openSerenaConfigDrawer(newAgentStage.id);
                    }
                }, 300);
            }
            
            showToast('success', `Agente "${name}" agregado al flujo`);
        }

    </script>
</body>
</html>

